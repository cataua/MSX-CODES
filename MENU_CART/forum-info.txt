i made a multicart menu of sorts for Konami4 recently. it also supports KonamiSCC mapper, but only supports games that live in the 0x8000-0xBFFF address range so far. it only supports 16KB and 8KB games (or smaller ones padded out to those sizes)

it is very very slow. you navigate using controller or keyboard. arrows select or switch pages, Space or Enter launches the selected game. each game when selected shows its "hotkey" which will instantly select it in the future, or launch the game if you already selected it. number keys 1 through 8 jump to different small chunks of the menu and cycle through those chunks. number key 0 also launches the selected game. number key 9 shuffles to a game chosen by RND. function keys F1 through F5 shifted and not shifted work similar to number keys, except Shift+F5 shuffles several times and then auto-launches!

please use it as you like, and be sure to propery respect ownership of the games. i made my example one using cartridges i have dumped and homebrews i have downloaded.

you will need to supply suitable games. here is a list of the ones I fed it with their SHA-1 hashes. the IPS patches correspond to fixes I wrote about recently here:

ef72dc1cf8b80e502240919cd610d201443fd2ee builtin-ice-man-4k.asc
2dacf7a08857cbdc706d24b4a46665113d16ff99 slot-01-gojira-16k.rom
a53d1ea775a6c90a84f1f36349540b16cf8307e4 slot-03-jump-coaster-8k.rom
cad653766b597a4aa130a9a1956ece77ba4d52bc slot-04-pachinko-ufo-16k.rom
0b9a870d1e6cc712a3efce2349fb1c1cf6902d22 slot-06-chack-n-pop-16k.rom
99f9e9753edbaee820e36a1a58f1cd7ae2b26265 slot-08-choro-q-16k.rom
5c7a13b64b48065231f05c35b4c8b209534f3a8b slot-0a-f16-fighting-falcon-16k.rom
b5d130a50f6939028702c1645426a29ec8ead6e5 slot-0c-mr-chin-8k.rom
167b226b54cc5b681a69d2c1509116ffaba868e4 slot-0e-ice-world-16k.rom
f3952b790ae2a8a1434b52bf816c56c9e680f73e slot-11-hole-in-one-16k.rom
8e2a2837c48bc8e2d2478043c728a4630982ba87 slot-13-clapton-2-8k.rom
8aa6d0aadf00de9112696da5b7dc6e3b62f2d9be slot-14-theseus-16k.rom
39ef139d8d66fb18b04dff8b9a5386011f497479 slot-16-jump-16k.rom
5460aa3be896ad949bea75444bc6e7e072a859b8 slot-18-midnight-building-16k.rom
917270dd44c63dc883289b4e0902fe6c812f5ea3 slot-1a-gundam-16k.rom
c5cdd1109b1e24906c5f0530f09e9ec95fbd7bb0 slot-1c-flapbird-8k.rom
1fbd7af23177ab1de799764d8a26bc2bbf85b042 slot-1e-pinky-chase-16k.rom
15cc2f7412373253e908689a778738d52656ad74 slot-21-xyzolog-16k.rom
0e63032a21ea4e42b67df98a24c2c30c6d88c319 slot-23-pyramid-warp-8k.rom
78079266711e60420480e4d95a39f0d7d974ad32 slot-24-pitfall-2-16k.rom
1edabc3226648b54ae98d524b31f37ca47c8c88b slot-26-rock-n-bolt-16k.rom
a4be5763cdf2dcd647b87e3aecbab28ecc69776e slot-28-tantan-tanuki-16k.rom
04bd78730b100dd879e2fbd3fe646d2bc9bbc46b slot-2a-soukoban-16k.rom
27e56fbec7fa39ce19d045b0dbc4217d290f92e2 slot-2c-picture-puzzle-8k.rom
221c76d6ac483fb1f11c87d37b9617f1e1d7bc6d slot-2e-sweet-acorn-16k.rom
8117ec66c0645a54422841a632cfd6602f35c4f9 slot-31-pastfinder-16k.rom
190bcab0325ded99f42f32976bf965f0164ad2a4 slot-33-peetan-8k.rom
f6711e1e2bac04d45b8988f1d03529ad777abf4e slot-34-tetsuman-16k.rom
4971bdd3db63d394fbc2186182c901ca4b32535b slot-36-space-invaders-16k.rom
5b17cb69697cf55dff1f0b8777e19d5abc1771fc slot-38-daishogai-keiba-16k.rom
b88e9c548873dcfd190e0e38f7b279344eea41ec slot-3a-pitfall-16k.rom slot-3a-pitfall-16k.ips
5db0acc008672f298d01686da4d56428b690b77f slot-3c-snail-maze-8k.rom
44baa180f6c9e0f140ac1f0afae75c412cb06b9e slot-3e-roller-ball-16k.rom slot-3e-roller-ball-16k.ips
rebuild.sh:

#!/bin/bash --
#
# What if you have a 512KB multicart split into DIP-selectable 128KB sections that supports the Konami4 mapper?
# What if you want to put multiple games in there, and you don't mind if they are selected for mainly technical reasons?
# What if you don't mind if you only get a single BASIC game in there?
# What if you don't mind a slow and ugly text-only menu system?
# What if you don't mind wasting some space idn your ROM ?
# What if you don't mind a brittle build process full of bugs?
#
# If the answer to all of the above was "yeah, sure, why not..." then this script can help you build such a multicart ROM image!
#
#                           ...
# This script rebuilds the 8xxx multicart from parts:
#
# - builtin-*-4k.asc
#     This is the (singular!) built-in BASIC game, stored as ASCII. It must be no larger than 4080 bytes when tokenized.
#     A tokenization of this code will live inside each 0x?D 8KB page at offset 0x10.
#     The name will be shown in the menu upper case and with - turned into a space.
# - slot-??-*-8k.rom, slot-??-*-16k.rom, slot-??-*-8k.ips, slot-??-*-16k.ips 
#     MSX ROM images. All of them must be runnable in the 0x8000-0xBFFF slot and not write to KonamiSCC or Konami4 mapper
#     register addresses. Also, they must have their entry point addresses written at offset 0x0002 right after the "AB"
#     bytes, as the menu will launch them by jumping to this address. BASIC ROM games won't work, sorry.
#
#     The -??- part in the filename is the hexadecimal lower case two-digit 8KB page number where the ROM will be placed
#     in the multicart. -?0- is reserved for the boot ROM and -?d- is reserved for the menu ROM.
#
#     The names -boot- and -menu- are special and reserved, do not use them. Empty names are not allowed.
#
#     All 8KB slots in the overall 512KB ROM must be filled. Remember that 16KB games occupy two of them!
#     The name will be shown in the menu upper case and with - turned into a space.
#     If an .ips file is found with the same name it will be applied to create the version stored in the multicart.
# - menu.asc
#     This is the BASIC multicart menu, stored as ASCII. It must be no larger than 3840 bytes when tokenized.
#     A tokenization of this code will live inside each 0x?D 8KB page at offset 0x1000.
#     This file will be modified by this script!
# - banner.txt
#     This is the ASCII banner. Double quotes will be displayed as visible cursor block characters, character code 0xFF.
#     This will be converted into code and inserted into menu.asc.
# - boot.rom
#     This is the machine code boot ROM. It must be 8KB. It needs to map the menu into 0x8000 and launch it.
#     This one boot from 0x4000..0x7FFF.
#
#     A copy of this rom will live inside each 0x?0 8KB boot page with the final byte modified to be the page number.
#     A copy of the final 0x100 bytes including page number will live inside each 0x?D 8KB menu page at offset 0x1f00.
#
# Build prerequisites:
#
# - awk (GNU version!)
# - bash
# - cut
# - diff
# - dd
# - fgrep
# - grep (GNU version!)
# - head
# - hexdump
# - ls
# - nl
# - od (GNU version!)
# - openmsx
# - python3
# - sed (GNU version!)
# - tr
# - wc
# - zip (Info-ZIP version!)
#
# ... probably others I forgot?
#
# The script is brittle. If it fails, try to fix it I guess?
#

rebuild() {
    openmsx --version &&
        python3 --version |
            fgrep Python &&
        awk --version |
            fgrep GNU &&
        sed --version |
            fgrep GNU &&
        grep --version |
            fgrep GNU &&
        zip --version |
            fgrep Info-ZIP &&
        hexdump --version &&
        echo hexdump is OK |
            hexdump -C |
            fgrep '00000000  68 65 78 64 75 6d 70 20  69 73 20 4f 4b 0a        |hexdump is OK.|' &&
        od --version |
            fgrep GNU &&
        echo od is OK |
            od -tx1 |
            fgrep '0000000 6f 64 20 69 73 20 4f 4b 0a' &&
        rm -vf \
           *~ \
           all-slots.rom \
           pirate-multicart.zip \
           pirate-multicart.rom \
           pirate-multicart-slot-?x.rom \
           autoexec.bas \
           menu.bas \
           menu.tmp \
           tmp.rom \
           tmp-slot-*.rom \
           builtin.bas \
           builtin.tmp \
           builtin.asc &&
        ls -d boot.rom &&
        test -f boot.rom &&
        ls -d menu.asc &&
        test -f menu.asc &&
        ls -d banner.txt &&
        test -f banner.txt &&
        set builtin-*-4k.asc &&
        ls -d "$*" &&
        test -f "$*" &&
        (
            printf '%s\n' slot-??-*.rom | sort | uniq -w 8 -d -D
            if [ :"$( printf '%s\n' slot-??-*.rom | sort | uniq -w 8 -d -D )" != :"" ]
            then
                echo overlapping slot ROM entries >&2
                exit 1
            fi
        ) &&
        cp -v "$*" builtin.asc &&
        (
            : ' line 1 and lines 1xx, 2xx, 3xx and 5xx will be tossed and replaced ' :
            : ' the special line 1 REMark will make exactly enough space at the beginning for a ROM header ' :
            : ' the PADDING REMarks ensure the program starts at address 0x9000 which leaves space for the built-in 4K BASIC game ' :
            : ' "double quotes" in banner.txt will be replaced with character 0xFF, the visible cursor block ' :
            echo '1 REM->HEADER<-'
            LC_ALL=C sed -ne 's/^  *//;/^[^1235]\|^[235][^0-9]\|^[1235][0-9][^0-9]\|^[1235][0-9][0-9][0-9]/ p' menu.asc |
                tr -d '\r'$'\x1a'
            (
                echo 'REM->PADDING<'
                i=$(( 0x21 ))
                while [ $i -lt $(( 0x1000 )) ]
                do
                    echo "REM->PADDING<-$(dd bs=1 count=$((0xff - 0x12)) < /dev/zero | LC_ALL=C tr '\0' $'\xff')"
                    i=$(( 0xFF + $i ))
                done
                echo 'REM -- v -- MENU'
                echo 'DIM II%(256),NN$(256)'
                printf '%s\n' builtin-*-4k.asc slot-*.rom |
                    grep -v -e '^slot-..-menu-8k\.rom$' -e '^slot-..-boot-8k\.rom$' |
                    nl -ba -v0 |
                    tr '\t' ' ' |
                    sed 's/^ *\([0-9][0-9]*\) *builtin-\(.*\)-\(..\|.\)k\.asc$/II%(\1)=1=1:NN$(\1)="\2"/;s/^ *\([0-9][0-9]*\) *slot-0*\([0-9a-fA-F]\|[1-9a-fA-F][0-9a-fA-F]\)-\(.*\)-\(..\|.\)k\.rom$/II%(\1)=\&H\2:NN$(\1)="\3"/;s/-/ /g' |
                    tr 'a-z' 'A-Z'
            ) |
                nl -ba -v100 |
                tr '\t' ' ' |
                sed 's/^ *//'
            echo '399 REM -- ^ -- MENU'
            echo '500 REM -- v -- BANNER'
            tr -d '\r'$'\x1a' < banner.txt |
                LC_ALL=C tr '"' $'\xFF' |
                LC_ALL=C nl -ba -v501 |
                LC_ALL=C sed 's/^ *\([0-9][0-9]*\)'$'\t''/\1 PRINT"/'
            echo '599 REM -- ^ -- BANNER'
        ) |
            LC_ALL=C sort -n |
            LC_ALL=C sed $'s/$/\r/' > menu.tmp &&
        printf '\x1a' >> menu.tmp &&
        (
            diff -u menu.asc menu.tmp ||
                mv -v menu.tmp menu.asc
        ) &&
        rm -vf menu.tmp &&
        openmsx -machine Sony_HB-501P -ext Sony_HBD-F1 -ext ram64k -diska . \
                -command $'set fastforward on' \
                -command $'after time 15 { type {\r load "menu.asc" \r }}' \
                -command $'after time 30 { type { save "menu.bas" \r }}' \
                -command $'after time 45 { type { save "menu.tmp", a \r }}' \
                -command $'after time 75 { quit }' &&
        \ls -d menu.tmp &&
        diff -u menu.asc menu.tmp &&
        rm -v menu.tmp &&
        \ls -ld menu.bas &&
        echo should be $(( 0x1f00 )) bytes or smaller &&
        test $( LC_ALL=C wc -c < menu.bas ) -le $(( 0x1f00 )) &&
        dd bs=1 skip=$(( 0x1000 )) count=1 < menu.bas | od -tx1 | awk '{print $2}' &&
        echo should have 00 byte at offset $(( 0x1000 )) &&
        test $( dd bs=1 skip=$(( 0x1000 )) count=1 < menu.bas | od -tx1 | awk '{print $2}' ) = 00 &&
        openmsx -machine Sony_HB-501P -ext Sony_HBD-F1 -ext ram64k -diska . \
                -command $'set fastforward on' \
                -command $'after time 15 { type {\r load "builtin.asc" \r }}' \
                -command $'after time 30 { type { 1 REM->HEADER<-\r save "builtin.bas" \r }}' \
                -command $'after time 45 { type { save "builtin.tmp", a \r }}' \
                -command $'after time 75 { quit }' &&
        \ls -d builtin.tmp &&
        diff -u <( printf '1 REM->HEADER<-\r\n'; cat builtin.asc ) builtin.tmp &&
        rm -v builtin.tmp &&
        \ls -ld builtin.bas &&
        echo should be $(( 0x1000 )) bytes or smaller &&
        test $( LC_ALL=C wc -c < builtin.bas ) -le $(( 0x1000 )) &&
        dd bs=1 skip=$(( 0x10 )) count=1 < builtin.bas | od -tx1 | awk '{print $2}' &&
        echo should have 00 byte at offset $(( 0x10 )) &&
        test $( dd bs=1 skip=$(( 0x10 )) count=1 < builtin.bas | od -tx1 | awk '{print $2}' ) = 00 &&
        (
            for p in 0 1 2 3
            do
                echo "$p"
                (dd bs=1 count=8191 < boot.rom; printf '\x'"${p}0" ) > slot-${p}0-boot-8k.rom
            done
        ) &&
        (
            for p in 0 1 2 3
            do
                (
                    printf 'AB\x00\x5f\0\0\0\0\x00\x90\0\0\0\0\0\0'
                    dd bs=1 skip=$(( 0x10 )) < builtin.bas
                    dd bs=1 count=$(( 0x1000 - $(LC_ALL=C wc -c builtin.bas | awk '{print $1}') )) if=/dev/zero
                    dd bs=1 skip=$(( 0x1000 )) < menu.bas
                    dd bs=1 count=$(( 0x2000 - $(LC_ALL=C wc -c menu.bas | awk '{print $1}') - 256 )) if=/dev/zero
                    dd bs=1 skip=$(( 8192 - 256 )) <  slot-${p}0-boot-8k.rom
                ) > slot-${p}d-menu-8k.rom
            done
        ) &&
        : > tmp.rom &&
        (
            i=$(( 0x00 ))
            for slot in slot-*.rom
            do
                if [ :"$slot" = :"${slot/slot-$(printf %02x $i)-/}" ]
                then
                    echo "$slot found, slot-$(printf %02x $i)-* expected" >&2
                    exit 1
                fi
                tmpslot="tmp-slot-$(printf %02x $i).rom"
                if ! rm -vf "$tmpslot"
                then
                    exit $?
                fi
                if [ -f "${slot/.rom/}.ips" ]
                then
                    if ! python3 apply_ips.py "${slot/.rom/}.ips" "$slot" "$tmpslot"
                    then
                        exit $?
                    fi
                else
                    if ! cp -v "$slot" "$tmpslot"
                    then
                        exit $?
                    fi
                fi
                if [ :"$slot" = :"${slot/-$(printf %dk $(( $( LC_ALL=C wc -c < "$tmpslot" ) / 1024 )) ).rom/}" -o $(( $( LC_ALL=C wc -c < "$tmpslot" ) % 0x2000 )) != 0 ]
                then
                    \ls -dl "$tmpslot"
                    echo "$slot found, slot-$(printf %02x $i)-*-$(printf %dk $(( $( LC_ALL=C wc -c < "$tmpslot" ) / 1024 )) ).rom expected" >&2
                    exit 1
                fi
                hexdump -C "$tmpslot" |
                    head -1
                if [ :"$slot" != :"${slot/slot-?0-boot-8k.rom/}" ] &&
                       ! hexdump -C "$tmpslot" |
                           head -1 |
                           grep -e '^00000000  41 42 .. [4567]' > /dev/null
                then
                    echo "$slot boot ROM entry point is not in the 0x4000-0x7FFF range" >&2
                    exit 1
                elif [ :"$slot" != :"${slot/slot-?d-menu-8k.rom/}" ] &&
                         ! hexdump -C "$tmpslot" |
                             head -1 |
                             grep -e '^00000000  41 42 .. .. .. .. .. ..  .. [89abAB]' > /dev/null
                then
                    echo "$slot menu ROM BASIC entry point is not in the 0x8000-0xBFFF range" >&2
                    exit 1
                elif [ :"$slot" = :"${slot/slot-?0-boot-8k.rom/}" -a :"$slot" = :"${slot/slot-?d-menu-8k.rom/}" ] &&
                         ! hexdump -C "$tmpslot" |
                             head -1 |
                             grep -e '^00000000  41 42 .. [89abAB]' > /dev/null
                then
                    echo "$slot regular ROM entry point is not in the 0x8000-0xBFFF range" >&2
                    exit 1
                fi
                i=$(( $i + ( $( LC_ALL=C wc -c < "$tmpslot" ) / 0x2000 ) ))
                if ! cat "$tmpslot" >> tmp.rom &&
                        rm -v "$tmpslot"
                then
                    exit $?
                fi
            done
            if [ $i != $(( 0x40 )) ]
            then
                echo expected to fill $(( 0x40 )) 8KB slots but actually filled $i >&2
                exit 1
            fi
        ) &&
        (
            if [ $(( (512 * 1024) - $(cat tmp.rom | LC_ALL=C wc -c) )) != 0 ]; then
                echo "slot contents do not sum to 512KB" >&2
                exit 1
            fi
        ) &&
        mv -v tmp.rom all-slots.rom &&
        (
            for p in 0 1 2 3
            do
                dd bs=$((128*1024)) count=1 skip=$p < all-slots.rom > pirate-multicart-slot-${p}x.rom
            done
        ) &&
        cp -v all-slots.rom pirate-multicart.rom &&
        rm -vf tmp-slot-*.rom &&
        echo if everything works you should see a menu here: &&
        echo ======================================== &&
        openmsx -machine Sony_HB-501P \
                pirate-multicart.rom \
                -romtype konami4 \
                -command $'set fastforward on' \
                -command $'after time 15 { message [get_screen] }' \
                -command $'after time 20 { quit }' &&
        echo ======================================== &&
        zip -j9r pirate-multicart.zip .
    exit $?
}

rebuild "$@"; exit $?
menu.asc: (the rebuild script modifies it, and ☐ is character code 0xFF; PADDING area will be replaced with the chosen BASIC game)

1 REM->HEADER<-
100 REM->PADDING<
101 REM->PADDING<-☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐
102 REM->PADDING<-☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐
103 REM->PADDING<-☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐
104 REM->PADDING<-☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐
105 REM->PADDING<-☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐
106 REM->PADDING<-☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐
107 REM->PADDING<-☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐
108 REM->PADDING<-☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐
109 REM->PADDING<-☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐
110 REM->PADDING<-☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐
111 REM->PADDING<-☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐
112 REM->PADDING<-☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐
113 REM->PADDING<-☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐
114 REM->PADDING<-☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐
115 REM->PADDING<-☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐
116 REM->PADDING<-☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐
117 REM -- v -- MENU
118 DIM II%(256),NN$(256)
119 II%(0)=1=1:NN$(0)="ICE MAN"
120 II%(1)=&H1:NN$(1)="GOJIRA"
121 II%(2)=&H3:NN$(2)="JUMP COASTER"
122 II%(3)=&H4:NN$(3)="PACHINKO UFO"
123 II%(4)=&H6:NN$(4)="CHACK N POP"
124 II%(5)=&H8:NN$(5)="CHORO Q"
125 II%(6)=&HA:NN$(6)="F16 FIGHTING FALCON"
126 II%(7)=&HC:NN$(7)="MR CHIN"
127 II%(8)=&HE:NN$(8)="ICE WORLD"
128 II%(9)=&H11:NN$(9)="HOLE IN ONE"
129 II%(10)=&H13:NN$(10)="CLAPTON 2"
130 II%(11)=&H14:NN$(11)="THESEUS"
131 II%(12)=&H16:NN$(12)="JUMP"
132 II%(13)=&H18:NN$(13)="MIDNIGHT BUILDING"
133 II%(14)=&H1A:NN$(14)="GUNDAM"
134 II%(15)=&H1C:NN$(15)="FLAPBIRD"
135 II%(16)=&H1E:NN$(16)="PINKY CHASE"
136 II%(17)=&H21:NN$(17)="XYZOLOG"
137 II%(18)=&H23:NN$(18)="PYRAMID WARP"
138 II%(19)=&H24:NN$(19)="PITFALL 2"
139 II%(20)=&H26:NN$(20)="ROCK N BOLT"
140 II%(21)=&H28:NN$(21)="TANTAN TANUKI"
141 II%(22)=&H2A:NN$(22)="SOUKOBAN"
142 II%(23)=&H2C:NN$(23)="PICTURE PUZZLE"
143 II%(24)=&H2E:NN$(24)="SWEET ACORN"
144 II%(25)=&H31:NN$(25)="PASTFINDER"
145 II%(26)=&H33:NN$(26)="PEETAN"
146 II%(27)=&H34:NN$(27)="TETSUMAN"
147 II%(28)=&H36:NN$(28)="SPACE INVADERS"
148 II%(29)=&H38:NN$(29)="DAISHOGAI KEIBA"
149 II%(30)=&H3A:NN$(30)="PITFALL"
150 II%(31)=&H3C:NN$(31)="SNAIL MAZE"
151 II%(32)=&H3E:NN$(32)="ROLLER BALL"
399 REM -- ^ -- MENU
400 SCREEN 1
401 COLOR 15,13,13
402 KEY OFF
403 KEY 1,"1":KEY 2,"3":KEY 3,"5":KEY 4,"7":KEY 5,"0":KEY 6,"2":KEY 7,"4":KEY 8,"6":KEY 9,"8":KEY 10,"999990"
404 CLS
500 REM -- v -- BANNER
501 PRINT"  =32-in-1!=  _-_  _-_  _-_
502 PRINT"_  _  _ _   _(o,O)(@,*)(0,O)
503 PRINT"|\/|__|||_((o)_☐____☐____☐__
504 PRINT"|\/||||| _|/O\ V /\ V /\ V /
505 PRINT"||||\_||\_|\_/_^_\/_^_\/_^_\
506 PRINT"
507 PRINT" how many 8xxx games exist?
599 REM -- ^ -- BANNER
1140 PRINT:X%=POS(0):Y%=CSRLIN
1150 E%=-1:P%=PEEK(&H9FFF)
1160 E%=E%+1:I%=II%(E%):N$=NN$(E%):IF N$<>"" AND (((P% AND &HF0)<>(I% AND &HF0)) OR I%=-1) THEN GOTO 1160
1165 IF N$="" THEN E%=0
1170 C%=0
1180 I%=II%(C%):N$=NN$(C%)
1190 IF N$="" AND C%>0 THEN E%=(E% + C%) MOD C%:GOTO 1170
1210 IF C%<>E% THEN C%=C%+1:GOTO 1180
1220 K%=0:FOR J%=0 TO 7:K%=K%-(K%=0)*(NN$(E%+J%)="")*(E%+J%):LOCATE X%,Y%+J%,0:PRINT CHR$(&H20-(J%=0)*(&H20+((E%+J%+K%) MOD &HC0)));" ";NN$(E%+J%+K%);SPACE$(30-LEN(NN$(E%+J%+K%)));:NEXT J%
1230 D$=MID$(BIN$(&H100+PEEK(&H9FFF)),2,4):E$=MID$(BIN$(&H100+I%),2,4)
1231 IF I%=-1 THEN E$=D$
1232 LOCATE 7,23,0:PRINT " DIPS ";D$;CHR$(&H3E+(D$=E$));E$;
1233 LOCATE X%,Y%,1
1235 T%=STICK(0):U%=STICK(1):V%=STICK(2):B%=STRIG(0)+STRIG(1)+STRIG(2)+STRIG(3)+STRIG(4)
1240 IF T%=1 OR U%=1 OR V%=1 THEN K$=CHR$(&H1E+0*LEN(INKEY$)):GOTO 1260
1241 IF T%=3 OR U%=3 OR V%=3 THEN K$=CHR$(&H1C+0*LEN(INKEY$)):GOTO 1260
1242 IF T%=5 OR U%=5 OR V%=5 THEN K$=CHR$(&H1F+0*LEN(INKEY$)):GOTO 1260
1243 IF T%=7 OR U%=7 OR V%=7 THEN K$=CHR$(&H1D+0*LEN(INKEY$)):GOTO 1260
1244 IF B%<>0 THEN K$=CHR$(&H20+0*LEN(INKEY$)):GOTO 1260
1250 K$=INKEY$:IF K$="" THEN GOTO 1230
1255 T%=STICK(0):U%=STICK(1):V%=STICK(2):B%=STRIG(0)+STRIG(1)+STRIG(2)+STRIG(3)+STRIG(4)
1260 IF ASC(K$)>=&H31 AND ASC(K$)<=&H38 AND (4*((ASC(K$)+1) MOD 10))<>(E% AND &HFC) AND NN$(4*((ASC(K$)+1) MOD 10))<>"" THEN E%=4*((ASC(K$)+1) MOD 10):GOTO 1170
1261 IF K$=CHR$(&H1E) THEN E%=E%-1:GOTO 1170
1262 IF K$=CHR$(&H1C) THEN E%=E%+8:GOTO 1170
1263 IF K$=CHR$(&H1F) THEN E%=E%+1:GOTO 1170
1264 IF K$=CHR$(&H1D) THEN E%=E%-8:GOTO 1170
1265 IF K$="9" THEN E%=-1:K$=CHR$(&H40 + (((RND(-(TIME XOR 256*RND(0))) * &HC0) AND &HBF) MOD &HC0))
1266 M%=&H100
1267 IF ASC(K$)>=&H40 AND NN$((ASC(K$) + &HC0) MOD M%)<>"" AND E%=(ASC(K$) + &HC0) MOD M% THEN GOTO 1280
1268 IF ASC(K$)>=&H40 AND NN$((ASC(K$) + &HC0) MOD M%)<>"" THEN E%=(ASC(K$) + &HC0) MOD M%:GOTO 1170
1269 M%=(M%/2) AND &HFF:IF M%>1 THEN GOTO 1267
1270 IF K$=" " OR K$=CHR$(&HD) OR K$="0" THEN GOTO 1280
1271 IF ASC(K$)>=&H31 AND ASC(K$)<=&H38 THEN E%=(E% AND &HFC) + ((E% + 1) AND &H3):GOTO 1170
1272 GOTO 1230
1280 IF INKEY$<>"" THEN GOTO 1280
1290 CLS:COLOR 15,4,7:LOCATE 0,0,0:PRINT "STARTING ";N$;"... ";
1295 ERASE II%,NN$
1296 IF I%=-1 THEN POKE &HF676,&H11:POKE &HF677,&H80:RUN
1300 T$=CHR$(&HAF)+CHR$(&HCD)+CHR$(&HC3)+CHR$(0)+CHR$(&H3E)+CHR$(I%+1)+CHR$(&H32)+CHR$(0)+CHR$(&HB0)+CHR$(&H32)+CHR$(0)+CHR$(&HA0)
1305 T$=T$+CHR$(&H3E)+CHR$(I%)+CHR$(&H32)+CHR$(0)+CHR$(&H90)+CHR$(&H32)+CHR$(0)+CHR$(&H80)+CHR$(&H2A)+CHR$(&H2)+CHR$(&H80)+CHR$(&HE9)+CHR$(&HC9)
1310 DEF USR=PEEK(VARPTR(T$)+1)+256*PEEK(VARPTR(T$)+2):PRINT USR(0):END
boot.rom: (was hand-written in a hex editor but should become asm some day)

00000000  41 42 00 5f 00 00 00 00  00 00 00 00 00 00 00 00  |AB._............|
00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
00001f00  f3 f5 e5 d5 c5 cd 38 01  0f 0f e6 03 4f 06 00 21  |......8.....O..!|
00001f10  c1 fc 09 7e e6 80 b1 cb  7f 28 09 4f 23 23 23 23  |...~.....(.O####|
00001f20  7e e6 c0 b1 26 80 cd 24  00 af 00 00 ee 0d 32 00  |~...&..$......2.|
00001f30  80 32 00 90 32 00 a0 32  00 b0 c1 d1 e1 f1 c9 00  |.2..2..2........|
00001f40  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
00002000
banner.txt: (began as figlet but then hacked by hand in text editor)

  =32-in-1!=  _-_  _-_  _-_
_  _  _ _   _(o,O)(@,*)(0,O)
|\/|__|||_((o)_"____"____"__
|\/||||| _|/O\ V /\ V /\ V /
||||\_||\_|\_/_^_\/_^_\/_^_\

 how many 8xxx games exist?
apply_ips.py:

#!/usr/bin/env python3
# -*- python -*-

import os, sys

def apply_ips(patch, original, force = False):
    IPS_MAGIC = b'PATCH'
    IPS_EOF = b'EOF'
    if not force: assert patch != IPS_MAGIC + IPS_EOF  # Don't apply empty patch
    assert patch[:len(IPS_MAGIC)] == IPS_MAGIC
    assert (patch[-len(IPS_EOF):] == IPS_EOF or patch[-(len(IPS_EOF) + 3):-3] == IPS_EOF)
    changed = original
    BAD_OFFSET = (IPS_EOF[0] << 16) | (IPS_EOF[1] << 8) | IPS_EOF[2]
    cursor = len(IPS_MAGIC) - len(patch)
    next_offset = 0
    while cursor < 0:
        assert cursor <= -3
        block_offset = (patch[cursor] << 16) | (patch[cursor + 1] << 8) | patch[cursor + 2]
        if cursor in (-len(IPS_EOF), -(len(IPS_EOF) + 3)):
            assert block_offset == BAD_OFFSET
            cursor += len(IPS_EOF)
            if cursor == -3:
                truncate_length = (patch[cursor] << 16) | (patch[cursor + 1] << 8) | patch[cursor + 2]
                if not force: assert truncate_length >= next_offset  # Don't truncate patched parts
                if not force: assert len(changed) >= truncate_length  # Too short to truncate
                changed = changed[:truncate_length]
                cursor = 0
            break
        assert patch[cursor:cursor + len(IPS_EOF)] != IPS_EOF
        if not force: assert block_offset >= next_offset  # No out-of-order blocks
        if not force: assert block_offset <= len(changed)  # No unmapped gaps
        cursor += 3
        assert cursor <= -(3 + len(IPS_EOF))  # Space for length + byte + EOF
        block_length = (patch[cursor] << 8) | patch[cursor + 1]
        cursor += 2
        if block_length == 0:
            assert cursor <= -(3 + len(IPS_EOF))  # Space for run length + byte + EOF
            block_length = (patch[cursor] << 8) | patch[cursor + 1]
            cursor += 2
            data = block_length * patch[cursor:cursor + 1]
            cursor += 1
        else:
            assert cursor <= -(block_length + len(IPS_EOF))  # Space for data + EOF
            data = patch[cursor:cursor + block_length]
            cursor += block_length
        if len(changed) < block_offset:
            changed = changed + (b'\0' * (block_offset - len(changed)))
        if not force: assert changed[block_offset:block_offset + block_length] != data  # Already applied?
        changed = changed[:block_offset] + data + changed[block_offset + block_length:]
        next_offset = block_offset + block_length
    assert cursor == 0
    return changed

def main(ips_file_name, original_file_name, changed_file_name, force = False):
    if not force: assert os.path.splitext(ips_file_name)[-1].lower() == '.ips'
    patch = open(ips_file_name, 'rb').read()
    original = open(original_file_name, 'rb').read()
    changed = apply_ips(patch, original, force = force)
    open(changed_file_name, 'wb').write(changed)

if __name__ == '__main__':
    force = False
    if sys.argv[1:2] in (['-force'], ['--force']):
        force = True
        try:
            (_, _force, ips_file_name, original_file_name) = sys.argv
            changed_file_name = os.path.join(os.path.split(original_file_name)[0], os.path.splitext(os.path.split(ips_file_name)[1])[0] + os.path.splitext(original_file_name)[1])
        except:
            (_, _force, ips_file_name, original_file_name, changed_file_name) = sys.argv
        assert _force in ('-force', '--force')
    else:
        try:
            (_, ips_file_name, original_file_name) = sys.argv
            changed_file_name = os.path.join(os.path.split(original_file_name)[0], os.path.splitext(os.path.split(ips_file_name)[1])[0] + os.path.splitext(original_file_name)[1])
        except:
            (_, ips_file_name, original_file_name, changed_file_name) = sys.argv
    main(ips_file_name, original_file_name, changed_file_name, force = force)


By bsittler

Champion (503)

bsittler's picture
05-08-2024, 21:31

It seems the "ROM scribbling" behavior of MSX-BASIC is due to it encountering and rewriting larger line numbers in GOTO etc. from the serialized form (two-byte integer with 0x0e token) to the RUN form (two-byte RAM address for the referenced tokenized line prefixed with 0x0d token) to try to speed up execution. Since the conversion seems to be done on-demand (lazily) RUNning the program and exercising all conditional branches before STOPping and doing a BSAVE could result in a fixed version, but it is a pain. I am still looking to see if there is some simpler way or maybe I need to write a "loader" script to do all the token scanning and fixups myself. On the bright side, BASIC always writes back the rewritten line references in descending address order so 0x0d will be the final byte written, meaning if the BASIC code lives in Konami4/KonamiSCC page 0x0d it will work fine. ASCII8 mapper wouldn't hit this at all because its mapper registers/switching registers aren't decoded inside the BASIC ROM region

By bsittler

Champion (503)

bsittler's picture
11-08-2024, 05:07

I went ahead and wrote a ROMifier for tokenized BASIC. With that, quite a few different BASIC programs can run from a page of a Konami4 ROM without disturbing the mapping. This also outputs ASCII equivalents for sanity-checking, and as part of that includes code for converting MSX BASIC floating point numbers to strings.

basld.py:

#!/usr/bin/env python3

from collections import namedtuple

import codecs
import os.path
import struct
import sys

RamRelocation = namedtuple('RamRelocation', ('relocation_offset', 'referenced_line_pointer', 'containing_line', 'relocation_text_offset', 'relocation_text_token'))

RomRelocation = namedtuple('RomRelocation', ('relocation_offset', 'referenced_line', 'containing_line'))

def basfloat_to_str(b):
    """
    Converts BASIC BCD floating-point to string.
    It will blindly convert values that do not round-trip or aren't even BCD, similarly to STR$().
    If too few bytes are given it will pad with 0x00 bytes.
    Some of the returned conversions containing 'E' are ambiguous as to whether the number was stored as single-precision or double-precision.
    We could show exponent -65 as plain unsigned zero as BASIC sometimes does, but choose not to so that data may be seen less ambiguously.
    """
    while len(b) < 8 and len(b) != 4:
        b += b'\x00'
    assert len(b) in (4, 8)
    format_disambiguator = '!#'[len(b) == 8]
    sign_and_biased_exponent, hex_mantissa = ord(b[:1]), codecs.encode(b[1:], 'hex').decode('iso-8859-1')
    sign_prefix = '-'[:sign_and_biased_exponent >= 0x80]
    exponent = (sign_and_biased_exponent & 0x7f) - 65
    decimal_mantissa = ''.join(chr(0x30 + int(digit, 16)) for digit in hex_mantissa)
    if exponent > -3 and exponent < 14:
        decimal_mantissa, exponent = ('000'+decimal_mantissa+'00000000000000')[:4+exponent] + '.' + ('000'+decimal_mantissa+'00000000000000')[4+exponent:], 0
        while decimal_mantissa[:1] == '0':
            decimal_mantissa = decimal_mantissa[1:]
        while decimal_mantissa[-1:] == '0':
            decimal_mantissa = decimal_mantissa[:-1]
    else:
        decimal_mantissa = decimal_mantissa[:1] + '.' + decimal_mantissa[1:]
    while decimal_mantissa[-1:] == '0' and '.' in decimal_mantissa:
        decimal_mantissa = decimal_mantissa[:-1]
    if decimal_mantissa[-1:] == '.':
        decimal_mantissa = decimal_mantissa[:-1]
    if decimal_mantissa == '0' and sign_prefix == '':
        exponent = 0
    while exponent != 0 and len(''.join(decimal_mantissa.lstrip('0').split('.'))) < 7 and format_disambiguator == '#':
        if '.' not in decimal_mantissa:
            decimal_mantissa += '.'
        decimal_mantissa += '0'
    return sign_prefix + decimal_mantissa + (('E' + '-+'[exponent > 0] + ('%02d' % abs(exponent))) if exponent != 0 else format_disambiguator[:('.' not in decimal_mantissa) or (format_disambiguator == '#')])

def test_basfloat():
    basfloat_test_expectations = {
        '00000000': '0!',
        '0000000000000000': '0#',
        '0000000000000001': '0.0000000000001E-65',
        '00000001': '0.00001E-65',
        '0000000100000000': '0.0000100E-65',
        '00100000': '1E-65',
        '0010000000000000': '1.000000E-65',
        '01100000': '1E-64',
        '0110000000000000': '1.000000E-64',
        '01234567': '2.34567E-64',
        '0123456700000000': '2.345670E-64',
        '0123456789ABCDEF': '2.3456789:;<=>?E-64',
        '11111111': '1.11111E-48',
        '1111111100000000': '1.111110E-48',
        '1111111111111111': '1.1111111111111E-48',
        '2020202020202020': '2.020202020202E-33',
        '3E100000': '1E-03',
        '3E10000000000000': '1.000000E-03',
        '3E999999': '9.99999E-03',
        '3E99999900000000': '9.999990E-03',
        '3E99999999999999': '9.9999999999999E-03',
        '3F100000': '.01',
        '3F10000000000000': '.01#',
        '40100000': '.1',
        '4010000000000000': '.1#',
        '40999999': '.999999',
        '4099999900000000': '.999999#',
        '4099999999999999': '.99999999999999#',
        '41100000': '1!',
        '4110000000000000': '1#',
        '41900000': '9!',
        '4190000000000000': '9#',
        '41999999': '9.99999',
        '4199999900000000': '9.99999#',
        '4199999999999999': '9.9999999999999#',
        '43123123': '123.123',
        '4312312300000000': '123.123#',
        '4312312345678901': '123.12345678901#',
        '46123456': '123456!',
        '4612345600000000': '123456#',
        '4612345612345678': '123456.12345678#',
        '46999999': '999999!',
        '4699999900000000': '999999#',
        '47100000': '1000000!',
        '4710000000000000': '1000000#',
        '4710000010000000': '1000001#',
        '4E100000': '10000000000000!',
        '4E10000000000000': '10000000000000#',
        '4E999999': '99999900000000!',
        '4E99999900000000': '99999900000000#',
        '4E99999999999999': '99999999999999#',
        '4F100000': '1E+14',
        '4F10000000000000': '1.000000E+14',
        '4F10000000000001': '1.0000000000001E+14',
        '60272C2E60272C2E': '2.72<2>60272<2>E+31',
        '7975636B': '7.5636;E+56',
        '7F7F7F7F': '7.?7?7?E+62',
        '7F7F7F7F00000000': '7.?7?7?0E+62',
        '7F7F7F7F7F7F7F7F': '7.?7?7?7?7?7?7?E+62',
        '7F999999': '9.99999E+62',
        '7F99999900000000': '9.999990E+62',
        '7F99999999999999': '9.9999999999999E+62',
        '7FFFFFFF': '?.?????E+62',
        '7FFFFFFF00000000': '?.?????0E+62',
        '7FFFFFFFFFFFFFFF': '?.?????????????E+62',
        '80000000': '-0E-65',
        '8000000000000000': '-0.0000000E-65',
        '8000000000000001': '-0.0000000000001E-65',
        '80000001': '-0.00001E-65',
        '8000000100000000': '-0.0000100E-65',
        '80100000': '-1E-65',
        '8010000000000000': '-1.000000E-65',
        '81100000': '-1E-64',
        '8110000000000000': '-1.000000E-64',
        '99999999': '-9.99999E-40',
        '9999999900000000': '-9.999990E-40',
        '9999999999999999': '-9.9999999999999E-40',
        'BE100000': '-1E-03',
        'BE10000000000000': '-1.000000E-03',
        'BE999999': '-9.99999E-03',
        'BE99999900000000': '-9.999990E-03',
        'BE99999999999999': '-9.9999999999999E-03',
        'BF100000': '-.01',
        'BF10000000000000': '-.01#',
        'C0100000': '-.1',
        'C010000000000000': '-.1#',
        'C0999999': '-.999999',
        'C099999900000000': '-.999999#',
        'C099999999999999': '-.99999999999999#',
        'C1100000': '-1!',
        'C110000000000000': '-1#',
        'C1900000': '-9!',
        'C190000000000000': '-9#',
        'C1999999': '-9.99999',
        'C199999900000000': '-9.99999#',
        'C199999999999999': '-9.9999999999999#',
        'C3123123': '-123.123',
        'C312312300000000': '-123.123#',
        'C312312345678901': '-123.12345678901#',
        'C6123456': '-123456!',
        'C612345600000000': '-123456#',
        'C612345612345678': '-123456.12345678#',
        'C6999999': '-999999!',
        'C699999900000000': '-999999#',
        'C7100000': '-1000000!',
        'C710000000000000': '-1000000#',
        'C710000010000000': '-1000001#',
        'CCCCCCCCCCCCCCCC': '-<<<<<<<<<<<<.<<#',
        'CE100000': '-10000000000000!',
        'CE10000000000000': '-10000000000000#',
        'CE999999': '-99999900000000!',
        'CE99999900000000': '-99999900000000#',
        'CE99999999999999': '-99999999999999#',
        'CF100000': '-1E+14',
        'CF10000000000000': '-1.000000E+14',
        'CF10000000000001': '-1.0000000000001E+14',
        'FF999999': '-9.99999E+62',
        'FF99999900000000': '-9.999990E+62',
        'FF99999999999999': '-9.9999999999999E+62',
        'FFFFFFFF': '-?.?????E+62',
        'FFFFFFFF00000000': '-?.?????0E+62',
        'FFFFFFFFFFFFFFFF': '-?.?????????????E+62',
    }
    basfloat_test_failures = {
        basfloat_hex: results
    for (basfloat_hex, results) in
        {
            basfloat_hex: dict(
                actual=basfloat_to_str(codecs.decode(basfloat_hex, 'hex')),
                expected=expected,
            )
        for (basfloat_hex, expected) in basfloat_test_expectations.items()
        }.items()
    if results['actual'] != results['expected']
    }
    assert not basfloat_test_failures, basfloat_test_failures

def basld(load_addr, bas, verbose = True):
    """
    Converts BASIC token stream from serialized format to runtime
    format relocated to the given load address, and also outputs a
    text serialization. In can also relocate a token stream that is
    already in memory format.
    """
    assert load_addr == int(load_addr)
    load_addr = int(load_addr)
    assert load_addr >= 0x8000
    assert load_addr < 0xFFFF
    assert bas[:1] in b'\x00\xff' # sanity check: serialized tokenized BASIC on disk starts with a single 0xFF byte; in memory it starts with a single 0x00 byte
    line_map = {}
    line_unmap = {}
    ram_relocations = []
    rom_relocations = []
    ram_start = None
    ram_address = None
    previous_line_number = None
    previous_line_start = 0
    bld = b'\x00' # tokenized BASIC loaded into RAM or ROM always begins with a single 0x00 byte
    text = ''
    while True:
        next_ram_address, = struct.unpack('<H', bas[len(bld):2+len(bld)])
        if ram_address is not None:
            previous_ram_address = ram_address - (len(bld) - previous_line_start)
            if ram_start is None:
                ram_start = previous_ram_address - len(bld)
            line_unmap[previous_ram_address - 1] = previous_line_number
        if next_ram_address == 0x0000:
            bld += struct.pack('<H', next_ram_address)
            if (len(bas) > len(bld)) and bas[:1] == '\xff':
                print('Extra bytes after token stream in serialized tokenized BASIC disk format')
            bld += bas[len(bld):]
            text += '\x1a'
            break
        assert next_ram_address >= 0x8000 and next_ram_address < 0xFFFF, "next_ram_address = 0x%(next_ram_address)x should be 0x8000 or higher" % {'next_ram_address': next_ram_address}
        if ram_address is not None:
            assert next_ram_address > ram_address
        line_number, = struct.unpack('<H', bas[2+len(bld):4+len(bld)])
        text += str(line_number) + ' '
        if previous_line_number is not None:
            assert line_number >= previous_line_number
        previous_line_number = line_number
        previous_line_start = len(bld)
        line_map[line_number] = len(bld) - 1
        offset = 4+len(bld)
        reference_type = None
        multiple_reference_possible = False
        do_not_resolve = False
        zero_means_off = False
        while True:
            token = bas[offset:1+offset]
            if bas[:1] == b'\xFF':
                assert token != b'\x0D' # RAM relocation should not be present in serialized input
            offset += 1
            if token == b':':
                reference_type = None
                multiple_reference_possible = False
                do_not_resolve = False
                zero_means_off = False
            if token == b'\xFF':
                token += bas[offset:1+offset]
                offset += 1
            elif token == b':' and bas[offset:offset+2] == b'\x8f\xe6':
                token += bas[offset:2+offset]
                offset += 2
            elif token == b':' and bas[offset:offset+1] == b'\xa1':
                token += bas[offset:1+offset]
                offset += 1
            elif token == b'\xa1':
                text += '\b' # not quite right, but as close as we can easily get
            text_token = {
                b'\x00': '\r\n',
                b'\x0B': '&O%o' % struct.unpack('<H', bas[offset:2+offset]),
                b'\x0C': '&H%X' % struct.unpack('<H', bas[offset:2+offset]),
                b'\x0D': '\N{right-pointing magnifying glass}\N{fullwidth left white parenthesis}@ 0x%X\N{fullwidth right white parenthesis}' % struct.unpack('<H', bas[offset:2+offset]),
                b'\x0E': '%u' % struct.unpack('<H', bas[offset:2+offset]),
                b'\x0F': '%u' % ord(bas[offset:1+offset]),
                b'\x11': '0',
                b'\x12': '1',
                b'\x13': '2',
                b'\x14': '3',
                b'\x15': '4',
                b'\x16': '5',
                b'\x17': '6',
                b'\x18': '7',
                b'\x19': '8',
                b'\x1a': '9',
                b'\x1c': '%u' % struct.unpack('<h', bas[offset:2+offset]),
                b'\x1d': basfloat_to_str(bas[offset:4+offset]),
                b'\x1f': basfloat_to_str(bas[offset:8+offset]),
                b':\x8F\xE6': "'",
                b':\xA1': 'ELSE',
                b'\x81': 'END',
                b'\x82': 'FOR',
                b'\x83': 'NEXT',
                b'\x84': 'DATA',
                b'\x85': 'INPUT',
                b'\x86': 'DIM',
                b'\x87': 'READ',
                b'\x88': 'LET',
                b'\x89': 'GOTO',
                b'\x8A': 'RUN',
                b'\x8B': 'IF',
                b'\x8C': 'RESTORE',
                b'\x8D': 'GOSUB',
                b'\x8E': 'RETURN',
                b'\x8F': 'REM',
                b'\x90': 'STOP',
                b'\x91': 'PRINT',
                b'\x92': 'CLEAR',
                b'\x93': 'LIST',
                b'\x94': 'NEW',
                b'\x95': 'ON',
                b'\x96': 'WAIT',
                b'\x97': 'DEF',
                b'\x98': 'POKE',
                b'\x99': 'CONT',
                b'\x9A': 'CSAVE',
                b'\x9B': 'CLOAD',
                b'\x9C': 'OUT',
                b'\x9D': 'LPRINT',
                b'\x9E': 'LLIST',
                b'\x9F': 'CLS',
                b'\xA0': 'WIDTH',
                b'\xA1': 'ELSE', # this should not happen, b':\xA1' is the canonical form
                b'\xA2': 'TRON',
                b'\xA3': 'TROFF',
                b'\xA4': 'SWAP',
                b'\xA5': 'ERASE',
                b'\xA6': 'ERROR',
                b'\xA7': 'RESUME',
                b'\xA8': 'DELETE',
                b'\xA9': 'AUTO',
                b'\xAA': 'RENUM',
                b'\xAB': 'DEFSTR',
                b'\xAC': 'DEFINT',
                b'\xAD': 'DEFSNG',
                b'\xAE': 'DEFDBL',
                b'\xAF': 'LINE',
                b'\xB0': 'OPEN',
                b'\xB1': 'FIELD',
                b'\xB2': 'GET',
                b'\xB3': 'PUT',
                b'\xB4': 'CLOSE',
                b'\xB5': 'LOAD',
                b'\xB6': 'MERGE',
                b'\xB7': 'FILES',
                b'\xB8': 'LSET',
                b'\xB8': 'LSET',
                b'\xB9': 'RSET',
                b'\xBA': 'SAVE',
                b'\xBB': 'LFILES',
                b'\xBC': 'CIRCLE',
                b'\xBD': 'COLOR',
                b'\xBE': 'DRAW',
                b'\xBF': 'PAINT',
                b'\xC0': 'BEEP',
                b'\xC1': 'PLAY',
                b'\xC2': 'PSET',
                b'\xC3': 'PRESET',
                b'\xC4': 'SOUND',
                b'\xC5': 'SCREEN',
                b'\xC6': 'VPOKE',
                b'\xC7': 'SPRITE',
                b'\xC8': 'VDP',
                b'\xC9': 'BASE',
                b'\xCA': 'CALL',
                b'\xCB': 'TIME',
                b'\xCC': 'KEY',
                b'\xCD': 'MAX',
                b'\xCE': 'MOTOR',
                b'\xCF': 'BLOAD',
                b'\xD0': 'BSAVE',
                b'\xD1': 'DSKO$',
                b'\xD2': 'SET',
                b'\xD3': 'NAME',
                b'\xD4': 'KILL',
                b'\xD5': 'IPL',
                b'\xD6': 'COPY',
                b'\xD7': 'CMD',
                b'\xD8': 'LOCATE',
                b'\xD9': 'TO',
                b'\xDA': 'THEN',
                b'\xDB': 'TAB(',
                b'\xDC': 'STEP',
                b'\xDD': 'USR',
                b'\xDE': 'FN',
                b'\xDF': 'SPC(',
                b'\xE0': 'NOT',
                b'\xE1': 'ERL',
                b'\xE2': 'ERR',
                b'\xE3': 'STRING$',
                b'\xE4': 'USING',
                b'\xE5': 'INSTR',
                b'\xE7': 'VARPTR',
                b'\xE8': 'CSRLIN',
                b'\xE9': 'ATTR$',
                b'\xEA': 'DSKI$',
                b'\xEB': 'OFF',
                b'\xEC': 'INKEY$',
                b'\xED': 'POINT',
                b'\xEE': '>',
                b'\xEF': '=',
                b'\xF0': '<',
                b'\xF1': '+',
                b'\xF2': '-',
                b'\xF3': '*',
                b'\xF4': '/',
                b'\xF5': '^',
                b'\xF6': 'AND',
                b'\xF7': 'OR',
                b'\xF8': 'XOR',
                b'\xF9': 'EQV',
                b'\xFA': 'IMP',
                b'\xFB': 'MOD',
                b'\xFC': '\\',
                b'\xFF\x81': 'LEFT$',
                b'\xFF\x82': 'RIGHT$',
                b'\xFF\x83': 'MID$',
                b'\xFF\x84': 'SGN',
                b'\xFF\x85': 'INT',
                b'\xFF\x86': 'ABS',
                b'\xFF\x87': 'SQR',
                b'\xFF\x88': 'RND',
                b'\xFF\x89': 'SIN',
                b'\xFF\x8A': 'LOG',
                b'\xFF\x8B': 'EXP',
                b'\xFF\x8C': 'COS',
                b'\xFF\x8D': 'TAN',
                b'\xFF\x8E': 'ATN',
                b'\xFF\x8F': 'FRE',
                b'\xFF\x90': 'INP',
                b'\xFF\x91': 'POS',
                b'\xFF\x92': 'LEN',
                b'\xFF\x93': 'STR$',
                b'\xFF\x94': 'VAL',
                b'\xFF\x95': 'ASC',
                b'\xFF\x96': 'CHR$',
                b'\xFF\x97': 'PEEK',
                b'\xFF\x98': 'VPEEK',
                b'\xFF\x99': 'SPACE$',
                b'\xFF\x9A': 'OCT$',
                b'\xFF\x9B': 'HEX$',
                b'\xFF\x9C': 'LPOS',
                b'\xFF\x9D': 'BIN$',
                b'\xFF\x9E': 'CINT',
                b'\xFF\x9F': 'CSNG',
                b'\xFF\xA0': 'CDBL',
                b'\xFF\xA1': 'FIX',
                b'\xFF\xA2': 'STICK',
                b'\xFF\xA3': 'STRIG',
                b'\xFF\xA4': 'PDL',
                b'\xFF\xA5': 'PAD',
                b'\xFF\xA6': 'DSKF',
                b'\xFF\xA7': 'FPOS',
                b'\xFF\xA8': 'CVI',
                b'\xFF\xA9': 'CVS',
                b'\xFF\xAA': 'CVD',
                b'\xFF\xAB': 'EOF',
                b'\xFF\xAC': 'LOC',
                b'\xFF\xAD': 'LOF',
                b'\xFF\xAE': 'MKI$',
                b'\xFF\xAF': 'MKS$',
                b'\xFF\xB0': 'MKD$',
            }.get(token, token.decode('iso-8859-1'))
            text += text_token
            is_possible_reference = False
            next_reference_type = None
            if text_token == '\r\n':
                # end of line
                break
            elif text_token == 'ON':
                multiple_reference_possible = True
                do_not_resolve = False
            elif text_token == 'SPRITE' and multiple_reference_possible:
                # ON SPRITE GOSUB does not work with resolved line numbers
                do_not_resolve = True
            elif text_token == 'ERROR':
                if multiple_reference_possible:
                    multiple_reference_possible = False
                    zero_means_off = True
            elif text_token == ' ':
                next_reference_type = reference_type
            elif text_token == ',':
                next_reference_type = reference_type if multiple_reference_possible else None
            elif (text_token in ('REM', "'")) and (token != b"'"):
                while bas[offset:1+offset] != b'\x00':
                    text += chr(ord(bas[offset:1+offset]))
                    offset += 1
            elif text_token in ('_', 'CALL', 'DATA'):
                # note that regular parsing of DATA and READ's parsing
                # of DATA work differently. this tries to mimic
                # regular parsing.
                while bas[offset:1+offset] not in b'\x00:':
                    text += chr(ord(bas[offset:1+offset]))
                    offset += 1
                    if text[-1:] == '"':
                        while bas[offset:1+offset] not in b'\x00"':
                            text += chr(ord(bas[offset:1+offset]))
                            offset += 1
                        if bas[offset:1+offset] == b'"':
                            text += '"'
                            offset += 1
            elif token == b'"':
                while bas[offset:1+offset] not in b'\x00"':
                    text += chr(ord(bas[offset:1+offset]))
                    offset += 1
                if bas[offset:1+offset] == b'"':
                    text += '"'
                    offset += 1
            elif token in b'\x0B\x0C\x1C':
                assert reference_type is None # not a line number reference
                # non-line number unsigned integer in unsigned-word format
                offset += 2
            elif token == b'\x0D':
                assert reference_type is not None # line number reference (RAM)
                line_pointer_value, = struct.unpack('<H', bas[offset:2+offset])
                offset += 2
                ram_relocations.append(RamRelocation(relocation_offset=offset-3, referenced_line_pointer=line_pointer_value, containing_line=line_number, relocation_text_offset=len(text) - len(text_token), relocation_text_token=text_token))
                next_reference_type = reference_type if multiple_reference_possible else None # some reference tokens allow multiple line numbers with commas
            elif token == b'\x0E':
                assert reference_type is not None # line number reference (unresolved)
                decimal_unsigned_integer_value, = struct.unpack('<H', bas[offset:2+offset])
                offset += 2
                if (reference_type == 'RESTORE') or do_not_resolve or (zero_means_off and decimal_unsigned_integer_value == 0):
                    # RESTORE references do not work when resolved
                    # ON SPRITE GOSUB references do not work when resolved
                    # ON ERROR GOTO 0 does not actually jump to zero even if line 0 exists
                    pass
                else:
                    rom_relocations.append(RomRelocation(relocation_offset=offset-3, referenced_line=decimal_unsigned_integer_value, containing_line=line_number))
                next_reference_type = reference_type if multiple_reference_possible else None # some reference tokens allow multiple line numbers with commas
            elif token in b'\x0F':
                assert reference_type is None # not a line number reference
                # non-line number unsigned integer in unsigned-word format
                offset += 1
            elif token >= b'\x11' and token <= b'\x1A':
                assert reference_type is None # not a line number reference
                # small decimal unsigned integer in bias-0x11 format
            elif token == b'\x1D':
                assert reference_type is None # not a line number reference
                # four-byte single-precision float
                offset += 4
            elif token == b'\x1F':
                assert reference_type is None # not a line number reference
                # eight-byte double-precision float
                offset += 8
            elif text_token in (
                    'AUTO',
                    'DELETE',
                    'ELSE',
                    'GOSUB',
                    'GOTO',
                    'LIST',
                    'LLIST',
                    'RENUM',
                    'RESTORE',
                    'RESUME',
                    'RETURN',
                    'RUN',
                    'THEN',
            ):
                # tokens possibly followed by one or more line references
                next_reference_type = text_token
            reference_type = next_reference_type
            pass
        assert text.endswith('\r\n')
        if ram_address is None:
            ram_address = next_ram_address - (offset - len(bld))
        if ram_start is None:
            ram_start = ram_address - len(bld)
        for i in range(len(ram_relocations))[::-1]:
            relocation_offset, referenced_line_pointer, containing_line, relocation_text_offset, relocation_text_token = ram_relocations[i] # process last-to-first to simplify text patching
            if containing_line != line_number:
                break
            if referenced_line_pointer < ram_start or referenced_line_pointer > (ram_start + len(bas) - 3):
                continue
            resolved_line, = struct.unpack('<H', bas[referenced_line_pointer - ram_start + 3:][:2])
            if referenced_line_pointer in line_unmap:
                assert resolved_line == line_unmap[referenced_line_pointer]
            old_relocation_text_token = relocation_text_token
            relocation_text_token = str(resolved_line)
            text = text[:relocation_text_offset] + relocation_text_token + text[relocation_text_offset + len(old_relocation_text_token):]
            relocation_text_token_size_delta = len(relocation_text_token) - len(old_relocation_text_token)
            ram_relocations[i] = ram_relocations[i]._replace(relocation_text_token=relocation_text_token)
            for j in range(i + 1, len(ram_relocations)):
                ram_relocations[j] = ram_relocations[j]._replace(relocation_text_offset=ram_relocations[j].relocation_text_offset + relocation_text_token_size_delta)
        if verbose:
            print(('0x%04X' + ['\N{rightwards arrow}0x%04X' % (load_addr + len(bld)), ''][ram_address == (load_addr + len(bld))] + ':') % ram_address, text.split('\r\n')[-2])
        line_unmap[(ram_address if ram_address is not None else next_ram_address - offset) - 1] = line_number
        if ram_address is not None:
            assert next_ram_address == ram_address + (offset - len(bld)), 'next_ram_address 0x%(next_ram_address)x should be == 0x%(expected_next_ram_address)x, i.e. ram_address 0x%(ram_address)x + (%(delta)x, i.e. offset 0x%(offset)x - len(bld) 0x%(len_bld)x)' % dict(next_ram_address=next_ram_address, expected_next_ram_address=ram_address + (offset - len(bld)), ram_address=ram_address, delta=offset - len(bld), offset=offset, len_bld=len(bld))
        ram_address = next_ram_address
        bld += struct.pack('<HH', offset + load_addr, line_number) + bas[4+len(bld):offset]
    assert len(bas) == len(bld)
    unresolved_ram_relocations = 0
    while len(ram_relocations):
        relocation_offset, referenced_line_pointer, containing_line, relocation_text_offset, relocation_text_token = ram_relocations.pop() # process last-to-first to simplify text patching
        assert ram_start is not None
        if referenced_line_pointer not in line_unmap:
            print('Undefined line reference &H%(referenced_line_pointer)X (%(referenced_line_pointer)d) in %(containing_line)d' % dict(referenced_line_pointer=referenced_line_pointer, containing_line=containing_line))
            unresolved_ram_relocations += 1
            continue
        resolved_line = line_unmap[referenced_line_pointer]
        rom_relocations.append(RomRelocation(relocation_offset=relocation_offset, referenced_line=resolved_line, containing_line=containing_line))
        bld=bld[:relocation_offset] + b'\x0E' + struct.pack('<H', resolved_line) + bld[3+relocation_offset:]
        text = text[:relocation_text_offset] + str(resolved_line) + text[relocation_text_offset + len(relocation_text_token):]
    assert unresolved_ram_relocations == 0, '%(unresolved_ram_relocations)d unresolved RAM relocations' % dict(unresolved_ram_relocations=unresolved_ram_relocations)
    unresolved_rom_relocations = 0
    for rom_relocation in rom_relocations:
        relocation_offset, referenced_line, containing_line = rom_relocation
        if referenced_line not in line_map:
            print('Undefined line %(referenced_line)d in %(containing_line)d' % dict(referenced_line=referenced_line, containing_line=containing_line))
            unresolved_rom_relocations += 1
            continue
        resolved_rom_address = load_addr + line_map[referenced_line]
        bld=bld[:relocation_offset] + b'\x0D' + struct.pack('<H', resolved_rom_address) + bld[3+relocation_offset:]
    if unresolved_rom_relocations > 0:
        print('Warning: %(unresolved_rom_relocations)d unresolved ROM relocations' % dict(unresolved_rom_relocations=unresolved_rom_relocations))
    return bld, text

def main():
    optional_verbose_flag = None
    try:
        prog_name, optional_verbose_flag, load_addr_hex, bas_file_name, bld_file_name, txt_file_name = sys.argv
        assert optional_verbose_flag in ('-v', '-verbose', '--verbose')
    except:
        prog_name, load_addr_hex, bas_file_name, bld_file_name, txt_file_name = sys.argv
    verbose = optional_verbose_flag is not None
    load_addr = int(load_addr_hex, 16)
    bas = open(bas_file_name, "rb").read()
    bld, text = basld(load_addr, bas, verbose = verbose)
    assert len(bld) == len(bas)
    bld2, text2 = basld(load_addr, bld, verbose = False)
    assert bld2 == bld # loading twice to the same address should not change the binary output
    assert text2 == text # loading twice to the same address should not change the text output
    open(bld_file_name, "wb").write(bld)
    open(txt_file_name, "wb").write(text.encode('iso-8859-1'))

if __name__ == "__main__":
    test_basfloat()
    main()
I also updated the rebuild.sh script:

#!/bin/bash --
#
# What if you have a 512KB multicart split into DIP-selectable 128KB sections that supports the Konami4 mapper?
# What if you want to put multiple games in there, and you don't mind if they are selected for mainly technical reasons?
# What if you don't mind if you only get a single BASIC game in there?
# What if you don't mind a slow and ugly text-only menu system?
# What if you don't mind wasting some space idn your ROM ?
# What if you don't mind a brittle build process full of bugs?
#
# If the answer to all of the above was "yeah, sure, why not..." then this script can help you build such a multicart ROM image!
#
#                           ...
# This script rebuilds the 8xxx multicart from parts:
#
# - slot-?0-*-7k.asc
#     These are BASIC games, stored as ASCII. They must be no larger than 7920 bytes when tokenized.
#     A tokenization of this code will live inside each 0x?0 8KB page at offset 0x10.
#     The program cannot use line number 0 or line numbers 65520 or above.
#     The name will be shown in the menu upper case and with - turned into a space.
# - slot-?1-*-4k.asc
#     These are BASIC games, stored as ASCII. They must be no larger than 4080 bytes when tokenized.
#     A tokenization of this code will live inside each 0x?1 8KB page at offset 0x10.
#     The program cannot use line number 0 or line numbers 65520 or above.
#     The name will be shown in the menu upper case and with - turned into a space.
# - slot-??-*-8k.rom, slot-??-*-16k.rom, slot-??-*-8k.ips, slot-??-*-16k.ips 
#     MSX ROM images. All of them must be runnable in the 0x8000-0xBFFF slot and not write to KonamiSCC or Konami4 mapper
#     register addresses. Also, they must have their entry point addresses written at offset 0x0002 right after the "AB"
#     bytes, as the menu will launch them by jumping to this address. BASIC ROM games won't work, sorry.
#
#     The -??- part in the filename is the hexadecimal lower case two-digit 8KB page number where the ROM will be placed
#     in the multicart. -?0- is reserved for the boot ROM and -?1- is reserved for the menu ROM and a BASIC game.
#
#     The names -tmp-boot- and -tmp-menu- are special and reserved, do not use them. Empty names are not allowed.
#
#     All 8KB slots in the overall 512KB ROM must be filled. Remember that 16KB games occupy two of them!
#     The name will be shown in the menu upper case and with - turned into a space.
#     If an .ips file is found with the same name it will be applied to create the version stored in the multicart.
# - menu.asc
#     This is the BASIC multicart menu, stored as ASCII. It must be no larger than 4096 bytes when tokenized.
#     A tokenization of this code will live inside each 0x?1 8KB page at offset 0x1000.
#     The program cannot use line number 0 or line numbers 65520 or above.
#     Lines 100-199 and lines 300-399 will be replaced by this script!
#     This file will be modified by this script!
# - banner.txt
#     This is the ASCII banner. Double quotes will be displayed as visible cursor block characters, character code 0xFF.
#     This will be converted into code and inserted into menu.asc.
# - boot.rom
#     This is the machine code boot ROM. It must be 8KB with the
#     region from 0x0010 through 0x1eff empty as it will be replaced
#     with a BASIC game in each ROM page. Bytes at offsets 0x0e and
#     0xef will be overwritten by the complement of the page number
#     and the page number, respectively.
#
#     It needs to map the menu into 0x8000 and launch it.
#
#     This one boots from 0x4000..0x7FFF.
#
#     A copy of this rom will live inside each 0x?0 8KB boot page with the final byte modified to be the page number.
#     A copy of the final byte (the page number) will live inside each 0x?D 8KB menu page at offset 0x100f.
#
# Build prerequisites:
#
# - awk (GNU version!)
# - bash
# - cut
# - diff
# - dd
# - fgrep
# - grep (GNU version!)
# - head
# - hexdump
# - ls
# - nl
# - od (GNU version!)
# - openmsx (including ROMs for Sony_HB-F1XV and Sony_HB-501P)
# - python3
# - script (util-linux one seems to be working)
# - sed (GNU version!)
# - tr
# - wc
# - zip (Info-ZIP version!)
#
# ... probably others I forgot?
#
# The script is brittle. If it fails, try to fix it I guess?
#

bas_in_rom_prelude() {
    # This BASIC snippet is added to all BASIC programs we prepare for
    # running from ROM.  It attempts to move BASIC's RAM usage to
    # 0xC000 and above to prevent writes to the ROM area which might
    # cause mapper state changes due to KonamiSCC/Konami4/Generic 8KB
    # mapper register switching address decoding in the 0x8000-0xBFFF
    # address range.
    #
    # It tries to move BOTTOM, TEMP, VARTAB, ARYTAB, and STREND.
    #
    # It needs to use \r\n line termination as it will be injected
    # into a TCL script with \n removed.  It needs to avoid unmatched
    # {} as it will be injected into TCL.
    #
    # Your BASIC should not define lines 0 or 65520-65529.
    printf '%s\r\n' \
           '0 IFI%=0THENI%=1:GOTO65521ELSEI%=0' \
           '65520 GOTO65529' \
           '65521 COLOR1,11,10:IF(PEEK(&H8000)<>&H41)OR(PEEK(&H8001)<>&H42)THEN65528' \
           '65522 IFPEEK(&HFC49)<&HC0THENPOKE&HFC49,&HC0:POKE&HFC48,&H0' \
           '65523 CLEAR300,PEEK(&HFC4A)+256*PEEK(&HFC4B):CLEAR' \
           '65524 IFPEEK(&HF6A8)<&HC0THENPOKE&HF6A8,&HC0:POKE&HF6A7,&H0' \
           '65525 IFPEEK(&HF6C3)<&HC0THENPOKE&HF6C3,&HC0:POKE&HF6C2,&H3' \
           '65526 IFPEEK(&HF6C5)<&HC0THENPOKE&HF6C5,&HC0:POKE&HF6C4,&H3' \
           '65527 IFPEEK(&HF6C7)<&HC0THENPOKE&HF6C7,&HC0:POKE&HF6C7,&H3' \
           '65528 I%=1:COLOR15,4,7:GOTO0' \
           '65529 ONERRORGOTO0'
}

scripted_openmsx() {
    : run openmsx without requiring a real TTY and attempt to prevent hangs :
    printf '[ running'
    printf ' %q' openmsx "$@"
    printf ' ]\n'
    (
        n=20
        while test $n -gt 0 && sleep 1 && printf '\0'
        do
            if [ $n -lt 15 ]
            then
                echo -n $'\r'"[ waiting ${n}s ] " >&2
            fi
            n=$(( $n - 1 ))
        done
        if [ $n -lt 10 ]
        then
            echo $'\r'"[ no more waiting ] " >&2
        fi
    ) |
        (
            exec > >(
                cat
            )
            script /dev/null \
                   --return \
                   --quiet \
                   --command 'exec openmsx '"$(printf "%q'' " "$@")"'; exit $?'
            exit $?
        )
    ret=$?
    if [ $ret != 0 ]
    then
        echo "[ openmsx exited with code $ret ]"
    fi
    return $ret
}

ascii_basic_crunch() {
    # attempt to slightly compact BASIC ASCII to avoid line buffer size limits
    #
    # the only implemented shortenings are:
    # 1. removal of space after initial line numbers
    # 2. replacement of some instances of PRINT with ?
    #
    # this tries to preserve "quoted things", REMarks,
    # 'remarks, and everything after DATA, CALL, and _
    #
    # input is stdin or supplied arguments, output is stdout
    cat "$@" |
        LC_ALL=C tr -d $'\r\x1a' | (
        while
            l=''
            # reads input lines including trailing spaces
            while read -r -s -N 1 c
            do
                if [ :"$c" = :$'\n' ]
                then
                    break
                fi
                l="$l$c"
            done
            test ${#l} -gt 0
        do
            n=""
            while [ :"${l#[0-9]}" != :"$l" ]
            do
                n="$n${l:0:1}"
                l="${l:1}"
            done
            if [ :"${l:0:1}" = :" " ]
            then
                l="${l:1}"
            fi
            r=""
            while [ ${#l} -gt 0 ]
            do
                x="${l:0:1}"
                l="${l:1}"
                if [ :"$x" = :'"' ]
                then
                    while [ :"${l:0:1}" != :'"' -a ${#l} -gt 0 ]
                    do
                        x="$x${l:0:1}"
                        l="${l:1}"
                    done
                    x="$x${l:0:1}"
                    l="${l:1}"
                elif [ :"$x" != :"${x//[A-Za-z]/}" ]
                then
                    while
                        y="${l:0:1}"
                        [ :"$y" != :"${y//[A-Za-z]/}" ]
                    do
                        x="$x$y"
                        l="${l:1}"
                    done
                fi
                if [ :"${x#PRINT}" != :"$x" ]
                then
                    x="?${x#PRINT}"
                fi
                if [ :"$x" = :'_' \
                      -o :"$x" = :"'" \
                      -o :"$x" != :"${x//[Rr][Ee][Mm]/}" \
                      -o :"$x" != :"${x//[Dd][Aa][Tt][Aa]/}" \
                      -o :"$x" != :"${x//[Cc][Aa][Ll][Ll]/}" \
                   ]
                then
                    x="$x$l"
                    l=''
                fi
                r="$r$x"
            done
            printf '%s\r\n' "$n$r"
        done
        printf '\x1a'
    )
}

rom_tokenize() {
    ascii_input="$1"
    tokenized_output="$2"
    tmp_ascii_output="$3"
    mkdir -p tmp-openmsx-diska &&
        ascii_basic_crunch < "$ascii_input" > tmp-openmsx-diska/input.asc &&
        ( rm -vf tmp-screen.txt || ( sleep 1 && rm -vf tmp-screen.txt ) ) &&
        scripted_openmsx \
            -machine Sony_HB-F1XV \
            -diska tmp-openmsx-diska \
            -command $'set fastforward on' \
            -command $'after time 25 { type {\r keyoff:screen0,,0:color15,1,1:width80:cls\r }}' \
            -command $'after time 30 { type { load "input.asc" \r }}' \
            -command $'after time 55 { type {'"$(bas_in_rom_prelude | ascii_basic_crunch | tr -d '\n')"' }}' \
            -command $'after time 75 { type { save "output.bas" \r }}' \
            -command $'after time 100 { type { save "output.asc", a \r }}' \
            -command $'after time 140 { set fp [open "tmp-screen.txt" w];puts $fp [get_screen]; close $fp; quit; }' &&
        (
            found="$(LC_ALL=C fgrep -e error -e Undefined -e Illegal -e Direct -e Ok tmp-screen.txt | LC_ALL=C tr -d '\r' | LC_ALL=C uniq -c | LC_ALL=C sed 's/  */ /g;s/  *$//;s/^  *//')"
            expected="4 Ok"
            if [ :"$found" != :"$expected" ] || ! [ -f tmp-openmsx-diska/output.bas ] || ! [ -f tmp-openmsx-diska/output.asc ]
            then
                echo 'OpenMSX screen:'
                cat tmp-screen.txt
                printf '%s: [%q]\n' found "$found" expected "$expected" >&2
                \ls -ld tmp-openmsx-diska/output.bas tmp-openmsx-diska/output.asc
                exit 1
            fi
        ) &&
        ( rm -vf tmp-screen.txt || ( sleep 1 && rm -vf tmp-screen.txt ) ) &&
        cp -v tmp-openmsx-diska/output.bas "$tokenized_output" &&
        cp -v tmp-openmsx-diska/output.asc "$tmp_ascii_output" &&
        ( rm -rvf tmp-openmsx-diska || ( sleep 1 && ( rm -rvf tmp-openmsx-diska || ( sleep 1 && rm -rvf tmp-openmsx-diska ) ) ) ) &&
        \ls -d "$tmp_ascii_output" &&
        echo ensuring "$ascii_input" re-saved with no differences &&
        diff -i -u <(
            (
                (
                    bas_in_rom_prelude
                    cat "$ascii_input" | LC_ALL=C tr -d $'\x1a'
                ) | LC_ALL=C sort -n
                printf '\x1a'
            ) | ascii_basic_crunch
        ) <( ascii_basic_crunch "$tmp_ascii_output" ) &&
        ( rm -v "$tmp_ascii_output" || ( sleep 1 && rm -v "$tmp_ascii_output" ) ) &&
        :
    return $?
}

rebuild() {
    : rebuild script for pirate multicart :

    echo rebuilding... &&
        echo checking script usability... &&
        script --version &&
        script --help |
            fgrep -e --command &&
        script --help |
            fgrep -e --return &&
        script --help |
            fgrep -e --quiet &&
        echo script: OK &&
        echo checking openmsx usability... &&
        scripted_openmsx --version &&
        scripted_openmsx --version |
            fgrep -e openMSX &&
        ! scripted_openmsx --this-flag-is-not-implemented &&
        echo openmsx: OK &&
        echo checking python3 usability... &&
        python3 --version |
            fgrep Python &&
        echo python3: OK &&
        echo checking awk usability... &&
        awk --version |
            fgrep GNU &&
        echo awk: OK &&
        echo checking sed usability... &&
        sed --version |
            fgrep GNU &&
        echo sed: OK &&
        echo checking grep usability... &&
        grep --version |
            fgrep GNU &&
        echo grep: OK &&
        echo checking zip usability... &&
        zip --version |
            fgrep Info-ZIP &&
        echo zip: OK &&
        echo checking hexdump usability... &&
        hexdump --version &&
        echo hexdump is OK |
            hexdump -C |
            fgrep '00000000  68 65 78 64 75 6d 70 20  69 73 20 4f 4b 0a        |hexdump is OK.|' &&
        echo hexdump: OK &&
        echo checking od usability... &&
        od --version |
            fgrep GNU &&
        echo od is OK |
            od -tx1 |
            fgrep '0000000 6f 64 20 69 73 20 4f 4b 0a' &&
        echo od: OK &&
        echo cleaning temporary and generated files... &&
        rm -vf \
           *~ \
           slot-?0-tmp-boot-8k.rom \
           slot-?1-tmp-menu-8k.rom \
           all-slots.rom \
           pirate-multicart.zip \
           pirate-multicart.rom \
           pirate-multicart-slot-?x.rom \
           tmp-menu.bas \
           tmp-menu.bld \
           tmp-menu.asc \
           tmp-all-slots.rom \
           tmp-screen.txt \
           tmp-slot-*.rom \
           tmp-slot-*.bas \
           tmp-slot-*.bld \
           tmp-slot-*.tmp &&
        ( rm -rvf tmp-openmsx-diska || ( sleep 1 && ( rm -rvf tmp-openmsx-diska || ( sleep 1 && rm -rvf tmp-openmsx-diska ) ) ) ) &&
        echo cleaning temporary and generated files: DONE &&
        echo checking openmsx Sony_HB-501P usability... &&
        ( rm -vf tmp-screen.txt || ( sleep 1 && rm -vf tmp-screen.txt ) ) &&
        scripted_openmsx \
            -machine Sony_HB-501P \
            -command $'set fastforward on' \
            -command $'after time 15 { type {\r ?"OpenMSX: ";"OK!" \r } }' \
            -command $'after time 20 { set fp [open "tmp-screen.txt" w];puts $fp [get_screen]; close $fp; quit; }' &&
        (
            found="$(LC_ALL=C fgrep 'OpenMSX: OK!' tmp-screen.txt | LC_ALL=C tr -d '\r' | LC_ALL=C uniq -c | LC_ALL=C sed 's/  */ /g;s/  *$//;s/^  *//')"
            expected="1 OpenMSX: OK!"
            if [ :"$found" != :"$expected" ]
            then
                echo 'OpenMSX screen:'
                cat tmp-screen.txt
                printf '%s: [%q]\n' found "$found" expected "$expected" >&2
                exit 1
            fi
        ) &&
        ( rm -vf tmp-screen.txt || ( sleep 1 && rm -vf tmp-screen.txt ) ) &&
        echo checking openmsx Sony_HB-501P usability: OK &&
        echo checking openmsx Sony_HB-F1XV usability... &&
        ( rm -vf tmp-screen.txt || ( sleep 1 && rm -vf tmp-screen.txt ) ) &&
        scripted_openmsx \
            -machine Sony_HB-F1XV \
            -command $'set fastforward on' \
            -command $'after time 15 { type {\r ?"OpenMSX: ";"OK!" \r } }' \
            -command $'after time 20 { set fp [open "tmp-screen.txt" w];puts $fp [get_screen]; close $fp; quit; }' &&
        (
            found="$(LC_ALL=C fgrep 'OpenMSX: OK!' tmp-screen.txt | LC_ALL=C tr -d '\r' | LC_ALL=C uniq -c | LC_ALL=C sed 's/  */ /g;s/  *$//;s/^  *//')"
            expected="1 OpenMSX: OK!"
            if [ :"$found" != :"$expected" ]
            then
                echo 'OpenMSX screen:'
                cat tmp-screen.txt
                printf '%s: [%q]\n' found "$found" expected "$expected" >&2
                exit 1
            fi
        ) &&
        ( rm -vf tmp-screen.txt || ( sleep 1 && rm -vf tmp-screen.txt ) ) &&
        echo checking openmsx Sony_HB-F1XV usability: OK &&
        echo checking for required file boot.rom... &&
        \ls -ld boot.rom &&
        test -f boot.rom &&
        echo should be $(( 0x2000 )) bytes &&
        test $( LC_ALL=C wc -c < boot.rom ) = $(( 0x2000 )) &&
        echo should have 00 byte at offset $(( 0x1fff )) &&
        test $( dd bs=1 skip=$(( 0x1fff )) count=1 < boot.rom | od -tx1 | awk '{print $2}' ) = 00 &&
        echo checking for required file boot.rom: OK &&
        echo checking for required file menu.asc... &&
        ls -d menu.asc &&
        test -f menu.asc &&
        echo checking for required file menu.asc: OK &&
        echo checking for required file banner.txt... &&
        ls -d banner.txt &&
        test -f banner.txt &&
        echo checking for required file banner.txt: OK &&
        echo checking for required file slot-\?\?-\*.rom non-overlap... &&
        (
            printf '%s\n' slot-??-*.rom | sort | uniq -w 8 -d -D
            if [ :"$( printf '%s\n' slot-??-*.rom | sort | uniq -w 8 -d -D )" != :"" ]
            then
                echo overlapping slot ROM entries >&2
                exit 1
            fi
        ) &&
        echo checking for required files slot-\?0-\*-7k.asc... &&
        set slot-{0,1,2,3}0-*-7k.asc &&
        ls -d "$@" &&
        test -f "$1" &&
        test -f "$2" &&
        test -f "$3" &&
        test -f "$4" &&
        echo checking for required files "$*": OK &&
        echo checking for required files slot-\?1-\*-4k.asc... &&
        set slot-{0,1,2,3}1-*-4k.asc &&
        ls -d "$@" &&
        test -f "$1" &&
        test -f "$2" &&
        test -f "$3" &&
        test -f "$4" &&
        echo checking for required files "$*": OK &&
        echo updating menu.asc... &&
        (
            : ' lines 1xx and 3xx will be tossed and replaced ' :
            : ' "double quotes" in banner.txt will be replaced with character 0xFF, the visible cursor block ' :
            LC_ALL=C sed -ne 's/^  *//;/^[^13]\|^[13][^0-9]\|^[13][0-9][^0-9]\|^[13][0-9][0-9][0-9]/ p' menu.asc |
                tr -d '\r'$'\x1a'
            (
                echo -n "DATA$(
                    printf '%s\n' slot-*.asc slot-*.rom |
                        sort |
                        grep -v -e '^slot-..-tmp-menu-8k\.rom$' -e '^slot-..-tmp-boot-8k\.rom$' |
                        sed -e 's/"/"+CHR$(34)+"/g' \
                            -e 's/^slot-\([0-9a-fA-F][0-9a-fA-F]\)-\(.*\)-\(..\|.\)k\.asc$/\&H8\1,"\2"/' \
                            -e 's/^slot-0*\([0-9a-fA-F]\|[1-9a-fA-F][0-9a-fA-F]\)-\(.*\)-\(..\|.\)k\.rom$/\&H\1,"\2"/' \
                            -e 's/-/ /g' |
                        tr 'a-z' 'A-Z'
                        echo '-1,""'
                    )" |
                    tr '\n' '/' |
                    sed -e 's_.\{,240\}/_&/DATA_g;s_\([^/]\)/\([^/]\)_\1,\2_g;s_//_/_g' |
                    tr '/' '\n'
                echo
            ) |
                LC_ALL=C grep . |
                nl -ba -v100 |
                tr '\t' ' ' |
                sed 's/^ *//'
            echo '198 RESTORE100:DIMII%(256),NN$(256):E%=0'
            echo '199 READII%(E%),NN$(E%):IFNN$(E%)<>""THENE%=E%+1:GOTO199'
            tr -d '\r'$'\x1a' < banner.txt |
                LC_ALL=C tr '"' $'\xFF' |
                LC_ALL=C nl -ba -v300 |
                LC_ALL=C sed 's/^ *\([0-9][0-9]*\)'$'\t''/\1 PRINT"/'
        ) |
            LC_ALL=C sort -n |
            LC_ALL=C sed $'s/$/\r/' > tmp-menu.asc &&
        printf '\x1a' >> tmp-menu.asc &&
        (
            diff -i -u <( ascii_basic_crunch menu.asc ) <( ascii_basic_crunch tmp-menu.asc ) ||
                mv -v tmp-menu.asc menu.asc
        ) &&
        rm -vf tmp-menu.asc &&
        echo updating menu.asc: OK &&
        echo generating tokenized tmp-menu.bas... &&
        rom_tokenize menu.asc tmp-menu.bas tmp-menu.asc &&
        \ls -ld tmp-menu.bas &&
        echo should be $(( 0x1000 )) bytes or smaller &&
        test $( LC_ALL=C wc -c < tmp-menu.bas ) -le $(( 0x1000 )) &&
        dd bs=1 count=1 < tmp-menu.bas | od -tx1 | awk '{print $2}' &&
        echo should have FF byte at offset 0 &&
        test $( dd bs=1 count=1 < tmp-menu.bas | od -tx1 | awk '{print $2}' ) = ff &&
        echo generating tokenized tmp-menu.bas: OK &&
        echo testing basld de-tokenization for tmp-menu.bas and generating tmp-menu.bld... &&
        python3 basld.py 0x9000 tmp-menu.bas tmp-menu.bld tmp-menu.asc &&
        echo ensuring tmp-menu.bas de-tokenized with no differences &&
        \ls -d tmp-menu.asc &&
        diff -i -u <(
            (
                (
                    bas_in_rom_prelude
                    cat menu.asc | LC_ALL=C tr -d $'\x1a'
                ) | LC_ALL=C sort -n
                printf '\x1a'
            ) | ascii_basic_crunch
        ) <( ascii_basic_crunch tmp-menu.asc ) &&
        ( rm -v tmp-menu.asc || ( sleep 1 && rm -v tmp-menu.asc ) ) &&
        echo ensuring tmp-menu.bld is the same length as tmp-menu.bas &&
        \ls -ld tmp-menu.bas tmp-menu.bld &&
        test $( LC_ALL=C wc -c < tmp-menu.bas ) = $( LC_ALL=C wc -c < tmp-menu.bld ) &&
        dd bs=1 count=1 < tmp-menu.bld | od -tx1 | awk '{print $2}' &&
        echo should have 00 byte at offset 0 &&
        test $( dd bs=1 count=1 < tmp-menu.bld | od -tx1 | awk '{print $2}' ) = 00 &&
        echo testing basld de-tokenization for tmp-menu.bas and generating tmp-menu.bld: OK &&
        (
            for p in 0 1 2 3
            do
                : &&
                    : ' larger game that coexists with the boot code ' : &&
                    : &&
                    echo generating tokenized tmp-slot-${p}0.bas... &&
                    rom_tokenize slot-${p}0-*-7k.asc tmp-slot-${p}0.bas tmp-slot-${p}0.asc &&
                    echo generating tokenized tmp-slot-${p}0.bas: OK &&
                    echo checking tokenized tmp-slot-${p}0.bas... &&
                    \ls -ld tmp-slot-${p}0.bas &&
                    echo should be $(( 0x2000 - 0x100 - 0x10 )) bytes or smaller &&
                    test $( LC_ALL=C wc -c < tmp-slot-${p}0.bas ) -le $(( 0x2000 - 0x100 - 0x10 )) &&
                    dd bs=1 count=1 < tmp-slot-${p}0.bas | od -tx1 | awk '{print $2}' &&
                    echo should have FF byte at offset 0 &&
                    test $( dd bs=1 count=1 < tmp-slot-${p}0.bas | od -tx1 | awk '{print $2}' ) = ff &&
                    echo checking tokenized tmp-slot-${p}0.bas: OK &&
                    echo testing basld de-tokenization for tmp-slot-${p}0.bas and generating tmp-slot-${p}0.bld... &&
                    python3 basld.py 0xA010 tmp-slot-${p}0.bas tmp-slot-${p}0.bld tmp-slot-${p}0.tmp &&
                    echo ensuring tmp-slot-${p}0.bas de-tokenized with no differences &&
                    \ls -d tmp-slot-${p}0.tmp &&
                    diff -i -u <(
                        (
                            (
                                bas_in_rom_prelude
                                cat slot-${p}0-*-7k.asc | LC_ALL=C tr -d $'\x1a'
                            ) | LC_ALL=C sort -n
                            printf '\x1a'
                        ) | ascii_basic_crunch
                    ) <( ascii_basic_crunch tmp-slot-${p}0.tmp ) &&
                    ( rm -v tmp-slot-${p}0.tmp || ( sleep 1 && rm -v tmp-slot-${p}0.tmp ) ) &&
                    echo ensuring tmp-slot-${p}0.bld is the same length as tmp-slot-${p}0.bas &&
                    \ls -ld tmp-slot-${p}0.bas tmp-slot-${p}0.bld &&
                    test $( LC_ALL=C wc -c < tmp-slot-${p}0.bas ) = $( LC_ALL=C wc -c < tmp-slot-${p}0.bld ) &&
                    dd bs=1 count=1 < tmp-slot-${p}0.bld | od -tx1 | awk '{print $2}' &&
                    echo should have 00 byte at offset 0 &&
                    test $( dd bs=1 count=1 < tmp-slot-${p}0.bld | od -tx1 | awk '{print $2}' ) = 00 &&
                    echo testing basld de-tokenization for tmp-slot-${p}0.bas and generating tmp-slot-${p}0.bld: OK &&
                    : &&
                    : ' smaller game that coexists with the menu ' : &&
                    : &&
                    echo generating tokenized tmp-slot-${p}1.bas... &&
                    rom_tokenize slot-${p}1-*-4k.asc tmp-slot-${p}1.bas tmp-slot-${p}1.asc &&
                    echo generating tokenized tmp-slot-${p}1.bas: OK &&
                    echo checking tokenized tmp-slot-${p}1.bas... &&
                    \ls -ld tmp-slot-${p}1.bas &&
                    echo should be $(( 0x1000 )) bytes or smaller &&
                    test $( LC_ALL=C wc -c < tmp-slot-${p}1.bas ) -le $(( 0x1000 )) &&
                    dd bs=1 count=1 < tmp-slot-${p}1.bas | od -tx1 | awk '{print $2}' &&
                    echo should have FF byte at offset 0 &&
                    test $( dd bs=1 count=1 < tmp-slot-${p}1.bas | od -tx1 | awk '{print $2}' ) = ff &&
                    echo checking tokenized tmp-slot-${p}1.bas: OK &&
                    echo testing basld de-tokenization for tmp-slot-${p}1.bas and generating tmp-slot-${p}1.bld... &&
                    python3 basld.py 0x8010 tmp-slot-${p}1.bas tmp-slot-${p}1.bld tmp-slot-${p}1.tmp &&
                    echo ensuring tmp-slot-${p}1.bas de-tokenized with no differences &&
                    \ls -d tmp-slot-${p}1.tmp &&
                    diff -i -u <(
                        (
                            (
                                bas_in_rom_prelude
                                cat slot-${p}1-*-4k.asc | LC_ALL=C tr -d $'\x1a'
                            ) | LC_ALL=C sort -n
                            printf '\x1a'
                        ) | ascii_basic_crunch
                    ) <( ascii_basic_crunch tmp-slot-${p}1.tmp ) &&
                    ( rm -v tmp-slot-${p}1.tmp || ( sleep 1 && rm -v tmp-slot-${p}1.tmp ) ) &&
                    echo ensuring tmp-slot-${p}1.bld is the same length as tmp-slot-${p}1.bas &&
                    \ls -ld tmp-slot-${p}1.bas tmp-slot-${p}1.bld &&
                    test $( LC_ALL=C wc -c < tmp-slot-${p}1.bas ) = $( LC_ALL=C wc -c < tmp-slot-${p}1.bld ) &&
                    dd bs=1 count=1 < tmp-slot-${p}1.bld | od -tx1 | awk '{print $2}' &&
                    echo should have 00 byte at offset 0 &&
                    test $( dd bs=1 count=1 < tmp-slot-${p}1.bld | od -tx1 | awk '{print $2}' ) = 00 &&
                    echo testing basld de-tokenization for tmp-slot-${p}1.bas and generating tmp-slot-${p}1.bld: OK &&
                    :
                ret=$?
                if [ $ret != 0 ]
                then
                    exit $ret
                fi
            done
        ) &&
        echo generating slot-\?0-tmp-boot-8k.rom... &&
        (
            for p in 0 1 2 3
            do
                echo "$p"
                (
                    dd bs=1 count=$(( 0x0e )) < boot.rom
                    LC_ALL=C printf "$(printf '\\x%02x' $(( 0x${p}0 ^ 0xff )) $(( 0x${p}0 )) )"
                    dd bs=1 < tmp-slot-${p}0.bld
                    dd bs=1 count=$(( 0x1f00 - ( 0x10 + $( LC_ALL=C wc -c < tmp-slot-${p}0.bld ) ) )) if=/dev/zero
                    dd bs=1 skip=$(( 0x1f00 )) < boot.rom
                ) > slot-${p}0-tmp-boot-8k.rom
            done
        ) &&
        echo generating slot-\?0-tmp-boot-8k.rom: OK &&
        echo generating slot-\?1-tmp-menu-8k.rom... &&
        (
            for p in 0 1 2 3
            do
                (
                    printf 'AB\x00\x5f\0\0\0\0\x00\x90\0\0\0\0'"$(printf '\\x%02x' $(( 0x${p}1 ^ 0xff )) $(( 0x${p}1 )) )"
                    dd bs=1 < tmp-slot-${p}1.bld
                    dd bs=1 count=$(( 0x1000 - ( 0x10 + $( LC_ALL=C wc -c < tmp-slot-${p}1.bld ) ) )) if=/dev/zero
                    dd bs=1 < tmp-menu.bld
                    dd bs=1 count=$(( 0x1000 - $( LC_ALL=C wc -c < tmp-menu.bld ) )) if=/dev/zero
                ) > slot-${p}1-tmp-menu-8k.rom
            done
        ) &&
        rm -vf tmp-slot-*.bas &&
        echo generating slot-\?1-tmp-menu-8k.rom: OK &&
        rm -vf tmp-menu.bas tmp-menu.bld &&
        echo generating all-slots.rom... &&
        rm -vf tmp-all-slots.rom &&
        : > tmp-all-slots.rom &&
        (
            i=$(( 0x00 ))
            for slot in slot-*.rom
            do
                if [ :"$slot" = :"${slot/slot-$(printf %02x $i)-/}" ]
                then
                    echo "$slot found, slot-$(printf %02x $i)-* expected" >&2
                    exit 1
                fi
                tmpslot="tmp-slot-$(printf %02x $i).rom"
                if ! rm -vf "$tmpslot"
                then
                    exit $?
                fi
                if [ -f "${slot/.rom/}.ips" ]
                then
                    echo applying IPS patch
                    if ! python3 apply_ips.py "${slot/.rom/}.ips" "$slot" "$tmpslot"
                    then
                        exit $?
                    fi
                else
                    if ! cp -v "$slot" "$tmpslot"
                    then
                        exit $?
                    fi
                fi
                expected_slot_suffix="-$(printf %dk $(( $( LC_ALL=C wc -c < "$tmpslot" ) / 1024 )) ).rom"
                if [ :"$slot" = :"${slot/"$expected_slot_suffix"/}" -o $(( $( LC_ALL=C wc -c < "$tmpslot" ) % 0x2000 )) != 0 ]
                then
                    \ls -dl "$tmpslot"
                    echo "$slot found, *$expected_slot_suffix expected with size a multiple of 8KB" >&2
                    exit 1
                fi
                hexdump -C "$tmpslot" |
                    head -1
                if [ :"$slot" != :"${slot/slot-?0-tmp-boot-8k.rom/}" ] &&
                       ! hexdump -C "$tmpslot" |
                           head -1 |
                           grep -e '^00000000  41 42 .. [4567]' > /dev/null
                then
                    echo "$slot boot ROM entry point is not in the 0x4000-0x7FFF range" >&2
                    exit 1
                elif [ :"$slot" != :"${slot/slot-?1-tmp-menu-8k.rom/}" ] &&
                         ! hexdump -C "$tmpslot" |
                             head -1 |
                             grep -e '^00000000  41 42 .. .. .. .. .. ..  .. [89abAB]' > /dev/null
                then
                    echo "$slot menu ROM BASIC entry point is not in the 0x8000-0xBFFF range" >&2
                    exit 1
                elif [ :"$slot" = :"${slot/slot-?0-tmp-boot-8k.rom/}" -a :"$slot" = :"${slot/slot-?1-tmp-menu-8k.rom/}" ] &&
                         ! hexdump -C "$tmpslot" |
                             head -1 |
                             grep -e '^00000000  41 42 .. [89abAB]' > /dev/null
                then
                    echo "$slot regular ROM entry point is not in the 0x8000-0xBFFF range" >&2
                    exit 1
                fi
                i=$(( $i + ( $( LC_ALL=C wc -c < "$tmpslot" ) / 0x2000 ) ))
                if ! cat "$tmpslot" >> tmp-all-slots.rom &&
                        rm -v "$tmpslot"
                then
                    exit $?
                fi
            done
            if [ $i != $(( 0x40 )) ]
            then
                echo expected to fill $(( 0x40 )) 8KB slots but actually filled $i >&2
                exit 1
            fi
        ) &&
        (
            if [ $(( (512 * 1024) - $(cat tmp-all-slots.rom | LC_ALL=C wc -c) )) != 0 ]; then
                echo "slot contents do not sum to 512KB" >&2
                exit 1
            fi
        ) &&
        cp -v tmp-all-slots.rom all-slots.rom &&
        rm -vf tmp-all-slots.rom &&
        rm -vf slot-?0-tmp-boot-8k.rom slot-?1-tmp-menu-8k.rom &&
        echo generating all-slots.rom: OK &&
        echo generating pirate-multicart-slot-\?x.rom... &&
        (
            for p in 0 1 2 3
            do
                dd bs=$((128*1024)) count=1 skip=$p < all-slots.rom > pirate-multicart-slot-${p}x.rom
            done
        ) &&
        echo generating pirate-multicart-slot-\?x.rom: OK &&
        echo generating pirate-multicart.rom... &&
        cp -v all-slots.rom pirate-multicart.rom &&
        echo generating pirate-multicart.rom: OK &&
        rm -vf tmp-slot-*.rom tmp-slot-*.bld &&
        echo testing pirate-multicart.rom... &&
        echo ... with mapper Konami4 &&
        ( rm -vf tmp-screen.txt || ( sleep 1 && rm -vf tmp-screen.txt ) ) &&
        scripted_openmsx \
            -machine Sony_HB-501P \
            pirate-multicart.rom \
            -romtype konami4 \
            -command $'set fastforward on' \
            -command $'after time 15 { set fp [open "tmp-screen.txt" w];puts $fp [get_screen]; close $fp; quit; }' &&
        (
            found="$(LC_ALL=C fgrep -e error -e Undefined -e Illegal -e Direct -e Ok -e DIPS tmp-screen.txt | LC_ALL=C tr -d '\r' | LC_ALL=C sed 's/  */ /g;s/  *$//;s/^  *//')"
            expected="DIPS 0000=0000"
            if [ :"$found" != :"$expected" ]
            then
                echo 'OpenMSX screen:'
                cat tmp-screen.txt
                printf '%s: [%q]\n' found "$found" expected "$expected" >&2
                exit 1
            fi
        ) &&
        ( rm -vf tmp-screen.txt || ( sleep 1 && rm -vf tmp-screen.txt ) ) &&
        echo ... with mapper KonamiSCC &&
        scripted_openmsx \
            -machine Sony_HB-501P \
            pirate-multicart.rom \
            -romtype konamiscc \
            -command $'set fastforward on' \
            -command $'after time 15 { set fp [open "tmp-screen.txt" w];puts $fp [get_screen]; close $fp; quit; }' &&
        (
            found="$(LC_ALL=C fgrep -e error -e Undefined -e Illegal -e Direct -e Ok -e DIPS tmp-screen.txt | LC_ALL=C tr -d '\r' | LC_ALL=C sed 's/  */ /g;s/  *$//;s/^  *//')"
            expected="DIPS 0000=0000"
            if [ :"$found" != :"$expected" ]
            then
                echo 'OpenMSX screen:'
                cat tmp-screen.txt
                printf '%s: [%q]\n' found "$found" expected "$expected" >&2
                exit 1
            fi
        ) &&
        ( rm -vf tmp-screen.txt || ( sleep 1 && rm -vf tmp-screen.txt ) ) &&
        echo testing pirate-multicart.rom: OK &&
        (
            for p in 0 1 2 3
            do
                echo testing pirate-multicart-slot-${p}x.rom... &&
                    ( rm -vf tmp-screen.txt || ( sleep 1 && rm -vf tmp-screen.txt ) ) &&
                    scripted_openmsx \
                        -machine Sony_HB-501P \
                        pirate-multicart-slot-${p}x.rom \
                        -romtype 8kb \
                        -command $'set fastforward on' \
                        -command $'after time 15 { set fp [open "tmp-screen.txt" w];puts $fp [get_screen]; close $fp; quit; }' &&
                    (
                        found="$(LC_ALL=C fgrep -e error -e Undefined -e Illegal -e Direct -e Ok -e DIPS tmp-screen.txt | LC_ALL=C tr -d '\r' | LC_ALL=C sed 's/  */ /g;s/  *$//;s/^  *//')"
                        pdips="$(python3 -c 'import sys; _, p = sys.argv; print(bin(0x100 | int(p) )[-4:])' $p)"
                        expected="DIPS $pdips=$pdips"
                        if [ :"$found" != :"$expected" ]
                        then
                            echo 'OpenMSX screen:'
                            cat tmp-screen.txt
                            printf '%s: [%q]\n' found "$found" expected "$expected" >&2
                            exit 1
                        fi
                    ) &&
                    ( rm -vf tmp-screen.txt || ( sleep 1 && rm -vf tmp-screen.txt ) ) &&
                    echo testing pirate-multicart-slot-${p}x.rom: OK
                ret=$?
                if [ $ret != 0 ]
                then
                    exit $ret
                fi
            done
        ) &&
        echo generating pirate-multicart.zip... &&
        zip -j9r pirate-multicart.zip . &&
        echo generating pirate-multicart.zip: OK &&
        echo rebuilding: OK
    exit $?
}

rebuild "$@"; exit $?
The boot.rom is also updated:

00000000  41 42 00 5f 00 00 00 00  00 00 00 00 00 00 00 00  |AB._............|
00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
00001f00  f3 f5 e5 d5 c5 cd 38 01  0f 0f e6 03 4f 06 00 21  |......8.....O..!|
00001f10  c1 fc 09 7e e6 80 b1 cb  7f 28 09 4f 23 23 23 23  |...~.....(.O####|
00001f20  7e e6 c0 b1 26 80 cd 24  00 af 00 00 ee 01 32 00  |~...&..$......2.|
00001f30  80 32 00 90 32 00 a0 32  00 b0 c1 d1 e1 f1 c9 00  |.2..2..2........|
00001f40  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
00002000
A new banner.txt is also added: (thanks to figlet for the letter shapes again)

                             
._ o.__._|_ _  ._ _    |_|_o 
|_)||(_| |_(/_ | | ||_|| |_| 
|                            
 """""                       
"     " "    " "    " "    " 
"     "  "  "   "  "   "  "  
 """""    ""     ""     ""   
"     "   ""     ""     ""   
"     "  "  "   "  "   "  "  
 """""  "    " "    " "    " 
                             
And of course menu.asc is also updated:

100 DATA&H800,"MARS LANDER",&H801,"ICE MAN",&H2,"MR CHIN",&H3,"JUMP COASTER",&H4,"PACHINKO UFO",&H6,"CHACK N POP",&H8,"CHORO Q",&HA,"F16 FIGHTING FALCON",&HC,"GOJIRA",&HE,"ICE WORLD",&H810,"SPACESCAPE",&H811,"SPACE MINES",&H12,"FLAPBIR1"
101 DATA&H13,"CLAPTON 2",&H14,"THESEUS",&H16,"JUMP",&H18,"MIDNIGHT BUILDING",&H1A,"GUNDAM",&H1C,"HOLE IN ONE",&H1E,"PINKY CHASE",&H820,"PINBALL",&H821,"UFO",&H22,"PICTURE PUZZLE",&H23,"PYRAMID WARP",&H24,"PITFALL 2",&H26,"ROCK N BOLT"
102 DATA&H28,"TANTAN TANUKI",&H2A,"SOUKOBAN",&H2C,"XYZOLOG",&H2E,"SWEET ACORN",&H830,"FREEBALL 2 3 8 9",&H831,"GALACTOR",&H32,"SNAIL MAZE",&H33,"PEETAN",&H34,"TETSUMAN",&H36,"SPACE INVADERS",&H38,"DAISHOGAI KEIBA",&H3A,"PITFALL",&H3C,"PASTFINDER"
103 DATA&H3E,"ROLLER BALL"
104 DATA-1,""
198 RESTORE100:DIMII%(256),NN$(256):E%=0
199 READII%(E%),NN$(E%):IFNN$(E%)<>""THENE%=E%+1:GOTO199
200 KEYOFF:SCREEN1:WIDTH30:COLOR15,13,13:CLS
210 U$=CHR$(&H1E):R$=CHR$(&H1C):V$=CHR$(&H1F):L$=CHR$(&H1D):KEY1,"1":KEY2,"3":KEY3,"5":KEY4,"7":KEY5,"0":KEY6,"2":KEY7,"4":KEY8,"6":KEY9,"8":KEY10,"999990>0>0>0"
300 PRINT"                             
301 PRINT"._ o.__._|_ _  ._ _    |_|_o 
302 PRINT"|_)||(_| |_(/_ | | ||_|| |_| 
303 PRINT"|                            
304 PRINT" ☐☐☐☐☐                       
305 PRINT"☐     ☐ ☐    ☐ ☐    ☐ ☐    ☐ 
306 PRINT"☐     ☐  ☐  ☐   ☐  ☐   ☐  ☐  
307 PRINT" ☐☐☐☐☐    ☐☐     ☐☐     ☐☐   
308 PRINT"☐     ☐   ☐☐     ☐☐     ☐☐   
309 PRINT"☐     ☐  ☐  ☐   ☐  ☐   ☐  ☐  
310 PRINT" ☐☐☐☐☐  ☐    ☐ ☐    ☐ ☐    ☐ 
311 PRINT"                             
600 X%=POS(0):Y%=CSRLIN:W$=""
610 E%=-1:R%=-1:P%=PEEK(&H800F):IF(PEEK(&H800E)<>(P%XOR&HFF))OR(PEEK(&H8000)<>&H41)OR(PEEK(&H8001)<>&H42)THENP%=0:R%=0
620 E%=E%+1:I%=II%(E%):N$=NN$(E%):IFN$<>""AND(((P%AND&HF0)<>(I%AND&HF0))ORI%=-1)THEN620ELSEIFN$=""THENE%=0
640 C%=0
650 I%=II%(C%):N$=NN$(C%)
660 IFN$=""ANDC%>0THENE%=(E%+C%)MODC%:GOTO640ELSEIFC%<>E%THENC%=C%+1:GOTO650
680 K%=0:FORJ%=0TO9:K%=K%-(K%=0)*(NN$(E%+J%)="")*(E%+J%):LOCATEX%,Y%+J%,0:PRINTCHR$(&H20-(J%=0)*(&H20+((E%+J%+K%)MOD&HC0)));" ";NN$(E%+J%+K%);SPACE$(30-LEN(NN$(E%+J%+K%)));:NEXTJ%
690 N%=TIMEOR7:Q%=(I%AND&HF0)+(P%AND&HF):IFR%<>0THENPOKE&HA000,Q%:POKE&HB000,Q%
700 IF(R%<>0)AND(PEEK(&HA00F)=Q%)AND(PEEK(&HA00E)=(Q%XOR&HFF))AND(PEEK(&HA000)=&H41)AND(PEEK(&HA001)=&H42)THENPOKE&H8000,Q%:POKE&H9000,Q%:P%=PEEK(&H800F)
710 D$=MID$(BIN$(&H100+PEEK(&H800F)),2,4):E$=MID$(BIN$(&H100+(I%AND&HFF)),2,4):F$=MID$(BIN$(&H100+PEEK(&HA00F)),2,4):IFR%=0THEND$="0000":F$=D$
720 LOCATE7,23,0:PRINT" DIPS ";D$;CHR$(&H3E+(D$=E$));E$;CHR$(&H21+(E$=F$));:LOCATEX%,Y%,1
730 T%=0:U%=STICK(1):V%=STICK(2):B%=STRIG(1)+STRIG(2)+STRIG(3)+STRIG(4)
740 K$="":IFT%=1ORU%=1ORV%=1THENK$=U$ELSEIFT%=3ORU%=3ORV%=3THENK$=R$ELSEIFT%=5ORU%=5ORV%=5THENK$=V$ELSEIFT%=7ORU%=7ORV%=7THENK$=L$
800 IFB%<>0THENK$=" "
810 IFK$=""THENK$=INKEY$:IFK$=""THENIFN%=TIMEOR7THEN730ELSE690
812 IFINSTR(",-",K$)THENT%=1:GOTO740ELSEIFINSTR(">*",K$)THENT%=3:GOTO740
815 IFINSTR(".+",K$)THENT%=5:GOTO740ELSEIFINSTR("</;",K$)THENT%=7:GOTO740ELSEIFINSTR("0="+CHR$(&HD),K$)THENB%=1:GOTO740
816 Q$=K$:IFK$<"!"THENQ$=MID$("?????????????0??????????????><-+0",1+ASC(K$),1)
817 W$=RIGHT$(W$+Q$,28):IFR%=0THENLOCATE0,22:PRINTW$;
820 IFK$>"0"ANDK$<"9"AND(5*((ASC(K$)+1)MOD10))<>(E%-(E%MOD5))ANDNN$(5*((ASC(K$)+1)MOD10))<>""THENE%=5*((ASC(K$)+1)MOD10):GOTO640
830 IFK$=U$THENE%=E%-1:GOTO640ELSEIFK$=R$THENE%=E%+10:GOTO640ELSEIFK$=V$THENE%=E%+1:GOTO640ELSEIFK$=L$THENE%=E%-10:GOTO640ELSEIFK$="9"THENE%=-1:K$=CHR$(&H40+(((RND(-(TIMEXOR256*RND(0)))*&HC0)AND&HBF)MOD&HC0))
880 M%=&H100
890 W%=K$>"?"ANDNN$((ASC(K$)+&HC0)MODM%)<>"":IFW%AND(E%=(ASC(K$)+&HC0)MODM%)THEN950
900 IFW%THENE%=(ASC(K$)+&HC0)MODM%:GOTO640
910 M%=M%\2:IFM%THEN890ELSEIFK$=" "THEN950ELSEIFK$>"0"ANDK$<"9"THENE%=(E%-(E%MOD5))+((E%+1)MOD5):GOTO640ELSE690
950 IFD$<>E$THENBEEP:GOTO640ELSEIFE$<>F$THENI%=I%AND&HF0F
980 CLS:COLOR15,4,7:LOCATE0,0,0:PRINTN$
985 IFINKEY$<>""THEN985
990 ERASEII%,NN$:IFR%=0THENPRINTW$:STOP
1000 IFI%AND&HFF00THENPOKE&HB000,I%AND&HFF:POKE&HA000,I%AND&HFF:POKE&HF676,&H11:POKE&HF677,&HA0-&H20*(I%MOD16):RUN
1010 T$=CHR$(&HAF)+CHR$(&HCD)+CHR$(&HC3)+CHR$(&H0)+CHR$(&H3E)+CHR$(I%+1)+CHR$(&H32)+CHR$(&H0)+CHR$(&HB0)+CHR$(&H32)+CHR$(&H0)+CHR$(&HA0)+CHR$(&H3E)+CHR$(I%)
1020 T$=T$+CHR$(&H32)+CHR$(&H0)+CHR$(&H90)+CHR$(&H32)+CHR$(&H0)+CHR$(&H80)+CHR$(&H2A)+CHR$(&H2)+CHR$(&H80)+CHR$(&HE9)+CHR$(&HC9)
1030 DEFUSR=PEEK(VARPTR(T$)+1)+256*PEEK(VARPTR(T$)+2):PRINTUSR(0):END


Hashes for the games I used in my own build:

fb70350a46ea7548913bf0c07cbddccffebd0650 *slot-00-mars-lander-7k.asc
ef72dc1cf8b80e502240919cd610d201443fd2ee *slot-01-ice-man-4k.asc
b5d130a50f6939028702c1645426a29ec8ead6e5 *slot-02-mr-chin-8k.rom
a53d1ea775a6c90a84f1f36349540b16cf8307e4 *slot-03-jump-coaster-8k.rom
cad653766b597a4aa130a9a1956ece77ba4d52bc *slot-04-pachinko-ufo-16k.rom
0b9a870d1e6cc712a3efce2349fb1c1cf6902d22 *slot-06-chack-n-pop-16k.rom
99f9e9753edbaee820e36a1a58f1cd7ae2b26265 *slot-08-choro-q-16k.rom
5c7a13b64b48065231f05c35b4c8b209534f3a8b *slot-0a-f16-fighting-falcon-16k.rom
2dacf7a08857cbdc706d24b4a46665113d16ff99 *slot-0c-gojira-16k.rom
167b226b54cc5b681a69d2c1509116ffaba868e4 *slot-0e-ice-world-16k.rom
5d22776defba52108624f5bfbf28d4a453ea5cf4 *slot-10-spacescape-7k.asc
3302288f2e9fe9cf3d8fc589a460bfcf110de4c5 *slot-11-space-mines-4k.asc
c5cdd1109b1e24906c5f0530f09e9ec95fbd7bb0 *slot-12-flapbir1-8k.rom
8e2a2837c48bc8e2d2478043c728a4630982ba87 *slot-13-clapton-2-8k.rom
8aa6d0aadf00de9112696da5b7dc6e3b62f2d9be *slot-14-theseus-16k.rom
39ef139d8d66fb18b04dff8b9a5386011f497479 *slot-16-jump-16k.rom
5460aa3be896ad949bea75444bc6e7e072a859b8 *slot-18-midnight-building-16k.rom
917270dd44c63dc883289b4e0902fe6c812f5ea3 *slot-1a-gundam-16k.rom
f3952b790ae2a8a1434b52bf816c56c9e680f73e *slot-1c-hole-in-one-16k.rom
1fbd7af23177ab1de799764d8a26bc2bbf85b042 *slot-1e-pinky-chase-16k.rom
e608f7a1363deef42771c24f83acb4af3601b921 *slot-20-pinball-7k.asc
5bb0e79a79703f04eddc3b34e6e8b66a3b4bf671 *slot-21-ufo-4k.asc
27e56fbec7fa39ce19d045b0dbc4217d290f92e2 *slot-22-picture-puzzle-8k.rom
0e63032a21ea4e42b67df98a24c2c30c6d88c319 *slot-23-pyramid-warp-8k.rom
78079266711e60420480e4d95a39f0d7d974ad32 *slot-24-pitfall-2-16k.rom
1edabc3226648b54ae98d524b31f37ca47c8c88b *slot-26-rock-n-bolt-16k.rom
a4be5763cdf2dcd647b87e3aecbab28ecc69776e *slot-28-tantan-tanuki-16k.rom
04bd78730b100dd879e2fbd3fe646d2bc9bbc46b *slot-2a-soukoban-16k.rom
15cc2f7412373253e908689a778738d52656ad74 *slot-2c-xyzolog-16k.rom
221c76d6ac483fb1f11c87d37b9617f1e1d7bc6d *slot-2e-sweet-acorn-16k.rom
40ac9691fa569c9ed3381bcefa9aa3375af299b1 *slot-30-freeball-2-3-8-9-7k.asc
d1597a4b29803b566b3cdb274ff30b406b1c18fc *slot-31-galactor-4k.asc
5db0acc008672f298d01686da4d56428b690b77f *slot-32-snail-maze-8k.rom
190bcab0325ded99f42f32976bf965f0164ad2a4 *slot-33-peetan-8k.rom
f6711e1e2bac04d45b8988f1d03529ad777abf4e *slot-34-tetsuman-16k.rom
4971bdd3db63d394fbc2186182c901ca4b32535b *slot-36-space-invaders-16k.rom
5b17cb69697cf55dff1f0b8777e19d5abc1771fc *slot-38-daishogai-keiba-16k.rom
de5b45cfb2fa20ca55f225085c2e6c3ccc314057 *slot-3a-pitfall-16k.ips
b88e9c548873dcfd190e0e38f7b279344eea41ec *slot-3a-pitfall-16k.rom
8117ec66c0645a54422841a632cfd6602f35c4f9 *slot-3c-pastfinder-16k.rom
c294a9fd1ada49bb4707324ec91b28b99c04b749 *slot-3e-roller-ball-16k.ips
44baa180f6c9e0f140ac1f0afae75c412cb06b9e *slot-3e-roller-ball-16k.rom
Several of the BASIC games are significantly smaller than their slots after tokenization. The "4k" and "7k" merely indicate the approximate size to which they will be padded by the build script after tokenization

By bsittler

Champion (503)

bsittler's picture
11-08-2024, 19:46

turns out my text serializations have a bug, though it won't ever show up in code entered normally.
in basld.py change this line:

                b'\x1c': '%u' % struct.unpack('<h', bas[offset:2+offset]),
to this:

                b'\x1c': '%d' % struct.unpack('<h', bas[offset:2+offset]),
It isn't reachable normally because minus sign is parsed as a separate token when MSX-BASIC is parsing ASCII numeric constants

By bsittler

Champion (503)

bsittler's picture
14-08-2024, 20:04

a new version of the multicart builder, this time with a simpler build process - use bash rebuild-all.sh or look at the comments in rebuild-all.sh to learn how to rebuild under Linux or WSL with fewer separate windows popping open

the menu now has two different versions of the RAM trampoline that it uses, one for launching BASIC games (which is a trampoline BASIC token stream that is reached via CONT) and the other for launching z80 machine code games (which is also written in z80 machine code)

menu.asc (displayed as if it were CP437!)

0 IFI%=0THENI%=1:GOTO65521ELSEI%=0
1 DEFINTA-Z
100 DATA&H800,"MARS LANDER",&H801,"ICE MAN",&H2,"MR CHIN",&H3,"JUMP COASTER",&H4,"PACHINKO UFO",&H6,"CHACK N POP",&H8,"CHORO Q",&HA,"F16 FIGHTING FALCON",&HC,"GOJIRA",&HE,"ICE WORLD",&H810,"SPACESCAPE",&H811,"SPACE MINES",&H12,"FLAPBIR1"
101 DATA&H13,"CLAPTON 2",&H14,"THESEUS",&H16,"JUMP",&H18,"MIDNIGHT BUILDING",&H1A,"GUNDAM",&H1C,"HOLE IN ONE",&H1E,"PINKY CHASE",&H820,"PINBALL",&H821,"UFO",&H22,"PICTURE PUZZLE",&H23,"PYRAMID WARP",&H24,"PITFALL 2",&H26,"ROCK N BOLT"
102 DATA&H28,"TANTAN TANUKI",&H2A,"SOUKOBAN",&H2C,"XYZOLOG",&H2E,"SWEET ACORN",&H830,"FREEBALL 2 3 8 9",&H831,"GALACTOR",&H32,"SNAIL MAZE",&H33,"PEETAN",&H34,"TETSUMAN",&H36,"SPACE INVADERS",&H38,"DAISHOGAI KEIBA",&H3A,"PITFALL",&H3C,"PASTFINDER"
103 DATA&H3E,"ROLLER BALL"
104 DATA-1,""
198 RESTORE100:DIMII%(256),NN$(256):E%=0
199 READII%(E%),NN$(E%):IFNN$(E%)<>""THENE%=E%+1:GOTO199
200 KEYOFF:SCREEN1,2,0:WIDTH29:COLOR15,1,1:CLS
210 U$=CHR$(30):R$=CHR$(28):V$=CHR$(31):L$=CHR$(29):KEY1,"1":KEY2,"3":KEY3,"5":KEY4,"7":KEY5,"0":KEY6,"2":KEY7,"4":KEY8,"6":KEY9,"8":KEY10,"999990>0>0>0"
300 PRINT"                             ";
301 PRINT"._ o.__._|_ _  ._ _    |_|_o ";
302 PRINT"|_)||(_| |_(/_ | | ||_|| |_| ";
303 PRINT"|                            ";
304 PRINT"                             ";
305 PRINT"                             ";
306 PRINT"                             ";
307 PRINT"                             ";
308 PRINT"                             ";
309 PRINT"                             ";
310 PRINT"                             ";
311 PRINT"                             ";
400 X=POS(0):Y=CSRLIN:G=-1:H=-1
410 E=-1:R=-1:P=PEEK(&H800F):IF(PEEK(&H800E)<>(P XOR255))OR(PEEK(&H8000)<>65)OR(PEEK(&H8001)<>66)THENP=0:R=0
420 E=E+1:I=II(E):N$=NN$(E):IFN$<>""AND(((P AND240)<>(I AND240))ORI=-1)THEN420ELSEIFN$=""THENE=0
430 C=0
440 I=II(C):N$=NN$(C)
450 IFN$=""ANDC>0THENE=(E+C)MODC:GOTO430ELSEIFC<>E THENC=C+1:GOTO440
460 F=(E-E MOD10):IFF<>G THENCOLOR4*((F\10)MOD4)-13*((F\10)MOD4=0),1,1
470 K=0:FORJ=0TO9:IF(F=G)AND(J<>(E MOD10))AND(J<>(H MOD10))THEN490
480 K=K-(K=0)*(NN$(F+J)="")*(F+J):LOCATEX,Y+J,0:PRINTCHR$(32-(J=(E MOD10))*(32+((F+J+K)MOD192)));:IFF<>G THENPRINT" ";NN$(F+J+K);SPACE$(30-LEN(NN$(E+J+K)));
490 NEXTJ:H=E
500 IFG<>F THENCOLOR15,4*((F\10)MOD4)-13*((F\10)MOD4=0),4*((F\10)MOD4)-13*((F\10)MOD4=0):G=F
510 N=TIMEOR7:Q=(I AND240)+(P AND15):IFR<>0THENPOKE&HA000,Q:POKE&HB000,Q
520 IF(R<>0)AND(PEEK(&HA00F)=Q)AND(PEEK(&HA00E)=(Q XOR255))AND(PEEK(&HA000)=65)AND(PEEK(&HA001)=66)THENPOKE&H8000,Q:POKE&H9000,Q:P=PEEK(&H800F)
530 D$=MID$(BIN$(256+PEEK(&H800F)),2,4):E$=MID$(BIN$(256+(I AND255)),2,4):F$=MID$(BIN$(256+PEEK(&HA00F)),2,4):IFR=0THEND$="0000":F$=D$
540 LOCATE7,23,0:PRINT" DIPS ";D$;CHR$(62+(D$=E$));E$;CHR$(33+(E$=F$));:LOCATEX,Y+(E MOD10),1
550 T=0:U=STICK(1):V=STICK(2):B=STRIG(1)+STRIG(2)+STRIG(3)+STRIG(4)
560 K$="":IFT=1ORU=1ORV=1THENK$=U$ELSEIFT=3ORU=3ORV=3THENK$=R$ELSEIFT=5ORU=5ORV=5THENK$=V$ELSEIFT=7ORU=7ORV=7THENK$=L$
570 IFB<>0THENK$=" "
580 IFK$=""THENK$=INKEY$:IFK$=""THENIFN=TIMEOR7THEN550ELSE510
590 IFINSTR(",-",K$)THENT=1:GOTO560ELSEIFINSTR(">*",K$)THENT=3:GOTO560
600 IFINSTR(".+",K$)THENT=5:GOTO560ELSEIFINSTR("</;",K$)THENT=7:GOTO560ELSEIFINSTR("0="+CHR$(13),K$)THENB=1:GOTO560
610 IFK$>"0"ANDK$<"9"AND(5*((ASC(K$)+1)MOD10))<>(E-(E MOD5))ANDNN$(5*((ASC(K$)+1)MOD10))<>""THENE=5*((ASC(K$)+1)MOD10):GOTO430
620 IFK$=U$THENE=E-1:GOTO430ELSEIFK$=R$THENE=E+10:GOTO430ELSEIFK$=V$THENE=E+1:GOTO430ELSEIFK$=L$THENE=E-10:GOTO430ELSEIFK$="9"THENE=-1:K$=CHR$(64+(((RND(-(TIMEXOR256*RND(0)))*192)AND191)MOD192))
630 M=256
640 W=K$>"?"ANDNN$((ASC(K$)+192)MODM)<>"":IFW AND(E=(ASC(K$)+192)MODM)THEN670
650 IFW THENE=(ASC(K$)+192)MODM:GOTO430
660 M=M\2:IFM THEN640ELSEIFK$=" "THEN670ELSEIFK$>"0"ANDK$<"9"THENE=(E-(E MOD5))+((E+1)MOD5):GOTO430ELSE510
670 IFD$<>E$THENBEEP:GOTO430ELSEIFE$<>F$THENI=I AND&HF0F
680 CLS:SCREEN1,0,1:COLOR15,4,7:LOCATE0,0,0:PRINTN$
690 IFINKEY$<>""THEN690
700 ERASEII,NN$:IFR=0THENSTOP
710 POKE&HB000,(I AND255)+1:POKE&HA000,(I AND255)+1:IFI=(I AND255)THEN750
720 T$=":ÿ"+CHR$(12)+CHR$(0)+"É,"+CHR$(15)+CHR$(I AND255)+":ÿ"+CHR$(12)+CHR$(0)+"Ç,"+CHR$(15)+CHR$(I AND255)+":ÿ"+CHR$(12)+"v÷,"+CHR$(15)+CHR$(17)+":ÿ"+CHR$(12)+"w÷,"+CHR$(15)+"Ç:è"
730 T$=T$+STRING$(4,CHR$(0)):T=(PEEK(VARPTR(T$)+1)+256*PEEK(VARPTR(T$)+2))-65536!
740 POKE&HF6BE,239:POKE&HF6BF,255:POKE&HF6C0,T AND255:POKE&HF6C1,((T+65536!)/256)AND255:CONT
750 T$="»═├"+CHR$(H0)+">"+CHR$(I)+"2"+CHR$(0)+"É2"+CHR$(0)+"Ç*"+CHR$(2)+"ÇΘ╔"
760 DEFUSR=PEEK(VARPTR(T$)+1)+256*PEEK(VARPTR(T$)+2):PRINTUSR(0):END
65520 GOTO65529
65521 COLOR1,11,10:IF(PEEK(&H8000)<>65)OR(PEEK(&H8001)<>66)THEN65528
65522 IFPEEK(&HFC49)<192THENPOKE&HFC49,192:POKE&HFC48,0
65523 CLEAR300,PEEK(&HFC4A)+256*PEEK(&HFC4B):CLEAR
65524 IFPEEK(&HF6A8)<192THENPOKE&HF6A8,192:POKE&HF6A7,0
65525 IFPEEK(&HF6C3)<192THENPOKE&HF6C3,192:POKE&HF6C2,3
65526 IFPEEK(&HF6C5)<192THENPOKE&HF6C5,192:POKE&HF6C4,3
65527 IFPEEK(&HF6C7)<192THENPOKE&HF6C7,192:POKE&HF6C6,3
65528 I%=1:COLOR15,4,7:GOTO0
65529 ONERRORGOTO0
Here's an ASCII Bash script to regenerate menu.bas:

(
printf %s $'0 IFI%=0THENI%=1:GOTO65521ELSEI%=0\r\n'
printf %s $'1 DEFINTA-Z\r\n'
printf %s $'100 DATA&H800,"MARS LANDER",&H801,"ICE MAN",&H2,"MR CHIN",&H3,"JUMP COASTER",&H4,"PACHINKO UFO",&H6,"CHACK N POP",&H8,"CHORO Q",&HA,"F16 FIGHTING FALCON",&HC,"GOJIRA",&HE,"ICE WORLD",&H810,"SPACESCAPE",&H811,"SPACE MINES",&H12,"FLAPBIR1"\r\n'
printf %s $'101 DATA&H13,"CLAPTON 2",&H14,"THESEUS",&H16,"JUMP",&H18,"MIDNIGHT BUILDING",&H1A,"GUNDAM",&H1C,"HOLE IN ONE",&H1E,"PINKY CHASE",&H820,"PINBALL",&H821,"UFO",&H22,"PICTURE PUZZLE",&H23,"PYRAMID WARP",&H24,"PITFALL 2",&H26,"ROCK N BOLT"\r\n'
printf %s $'102 DATA&H28,"TANTAN TANUKI",&H2A,"SOUKOBAN",&H2C,"XYZOLOG",&H2E,"SWEET ACORN",&H830,"FREEBALL 2 3 8 9",&H831,"GALACTOR",&H32,"SNAIL MAZE",&H33,"PEETAN",&H34,"TETSUMAN",&H36,"SPACE INVADERS",&H38,"DAISHOGAI KEIBA",&H3A,"PITFALL",&H3C,"PASTFINDER"\r\n'
printf %s $'103 DATA&H3E,"ROLLER BALL"\r\n'
printf %s $'104 DATA-1,""\r\n'
printf %s $'198 RESTORE100:DIMII%(256),NN$(256):E%=0\r\n'
printf %s $'199 READII%(E%),NN$(E%):IFNN$(E%)<>""THENE%=E%+1:GOTO199\r\n'
printf %s $'200 KEYOFF:SCREEN1,2,0:WIDTH29:COLOR15,1,1:CLS\r\n'
printf %s $'210 U$=CHR$(30):R$=CHR$(28):V$=CHR$(31):L$=CHR$(29):KEY1,"1":KEY2,"3":KEY3,"5":KEY4,"7":KEY5,"0":KEY6,"2":KEY7,"4":KEY8,"6":KEY9,"8":KEY10,"999990>0>0>0"\r\n'
printf %s $'300 PRINT"                             ";\r\n'
printf %s $'301 PRINT"._ o.__._|_ _  ._ _    |_|_o ";\r\n'
printf %s $'302 PRINT"|_)||(_| |_(/_ | | ||_|| |_| ";\r\n'
printf %s $'303 PRINT"|                            ";\r\n'
printf %s $'304 PRINT" \377\377\377\377\377                       ";\r\n'
printf %s $'305 PRINT"\377     \377 \377    \377 \377    \377 \377    \377 ";\r\n'
printf %s $'306 PRINT"\377     \377  \377  \377   \377  \377   \377  \377  ";\r\n'
printf %s $'307 PRINT" \377\377\377\377\377    \377\377     \377\377     \377\377   ";\r\n'
printf %s $'308 PRINT"\377     \377   \377\377     \377\377     \377\377   ";\r\n'
printf %s $'309 PRINT"\377     \377  \377  \377   \377  \377   \377  \377  ";\r\n'
printf %s $'310 PRINT" \377\377\377\377\377  \377    \377 \377    \377 \377    \377 ";\r\n'
printf %s $'311 PRINT"                             ";\r\n'
printf %s $'400 X=POS(0):Y=CSRLIN:G=-1:H=-1\r\n'
printf %s $'410 E=-1:R=-1:P=PEEK(&H800F):IF(PEEK(&H800E)<>(P XOR255))OR(PEEK(&H8000)<>65)OR(PEEK(&H8001)<>66)THENP=0:R=0\r\n'
printf %s $'420 E=E+1:I=II(E):N$=NN$(E):IFN$<>""AND(((P AND240)<>(I AND240))ORI=-1)THEN420ELSEIFN$=""THENE=0\r\n'
printf %s $'430 C=0\r\n'
printf %s $'440 I=II(C):N$=NN$(C)\r\n'
printf %s $'450 IFN$=""ANDC>0THENE=(E+C)MODC:GOTO430ELSEIFC<>E THENC=C+1:GOTO440\r\n'
printf %s $'460 F=(E-E MOD10):IFF<>G THENCOLOR4*((F\\10)MOD4)-13*((F\\10)MOD4=0),1,1\r\n'
printf %s $'470 K=0:FORJ=0TO9:IF(F=G)AND(J<>(E MOD10))AND(J<>(H MOD10))THEN490\r\n'
printf %s $'480 K=K-(K=0)*(NN$(F+J)="")*(F+J):LOCATEX,Y+J,0:PRINTCHR$(32-(J=(E MOD10))*(32+((F+J+K)MOD192)));:IFF<>G THENPRINT" ";NN$(F+J+K);SPACE$(30-LEN(NN$(E+J+K)));\r\n'
printf %s $'490 NEXTJ:H=E\r\n'
printf %s $'500 IFG<>F THENCOLOR15,4*((F\\10)MOD4)-13*((F\\10)MOD4=0),4*((F\\10)MOD4)-13*((F\\10)MOD4=0):G=F\r\n'
printf %s $'510 N=TIMEOR7:Q=(I AND240)+(P AND15):IFR<>0THENPOKE&HA000,Q:POKE&HB000,Q\r\n'
printf %s $'520 IF(R<>0)AND(PEEK(&HA00F)=Q)AND(PEEK(&HA00E)=(Q XOR255))AND(PEEK(&HA000)=65)AND(PEEK(&HA001)=66)THENPOKE&H8000,Q:POKE&H9000,Q:P=PEEK(&H800F)\r\n'
printf %s $'530 D$=MID$(BIN$(256+PEEK(&H800F)),2,4):E$=MID$(BIN$(256+(I AND255)),2,4):F$=MID$(BIN$(256+PEEK(&HA00F)),2,4):IFR=0THEND$="0000":F$=D$\r\n'
printf %s $'540 LOCATE7,23,0:PRINT" DIPS ";D$;CHR$(62+(D$=E$));E$;CHR$(33+(E$=F$));:LOCATEX,Y+(E MOD10),1\r\n'
printf %s $'550 T=0:U=STICK(1):V=STICK(2):B=STRIG(1)+STRIG(2)+STRIG(3)+STRIG(4)\r\n'
printf %s $'560 K$="":IFT=1ORU=1ORV=1THENK$=U$ELSEIFT=3ORU=3ORV=3THENK$=R$ELSEIFT=5ORU=5ORV=5THENK$=V$ELSEIFT=7ORU=7ORV=7THENK$=L$\r\n'
printf %s $'570 IFB<>0THENK$=" "\r\n'
printf %s $'580 IFK$=""THENK$=INKEY$:IFK$=""THENIFN=TIMEOR7THEN550ELSE510\r\n'
printf %s $'590 IFINSTR(",-",K$)THENT=1:GOTO560ELSEIFINSTR(">*",K$)THENT=3:GOTO560\r\n'
printf %s $'600 IFINSTR(".+",K$)THENT=5:GOTO560ELSEIFINSTR("</;",K$)THENT=7:GOTO560ELSEIFINSTR("0="+CHR$(13),K$)THENB=1:GOTO560\r\n'
printf %s $'610 IFK$>"0"ANDK$<"9"AND(5*((ASC(K$)+1)MOD10))<>(E-(E MOD5))ANDNN$(5*((ASC(K$)+1)MOD10))<>""THENE=5*((ASC(K$)+1)MOD10):GOTO430\r\n'
printf %s $'620 IFK$=U$THENE=E-1:GOTO430ELSEIFK$=R$THENE=E+10:GOTO430ELSEIFK$=V$THENE=E+1:GOTO430ELSEIFK$=L$THENE=E-10:GOTO430ELSEIFK$="9"THENE=-1:K$=CHR$(64+(((RND(-(TIMEXOR256*RND(0)))*192)AND191)MOD192))\r\n'
printf %s $'630 M=256\r\n'
printf %s $'640 W=K$>"?"ANDNN$((ASC(K$)+192)MODM)<>"":IFW AND(E=(ASC(K$)+192)MODM)THEN670\r\n'
printf %s $'650 IFW THENE=(ASC(K$)+192)MODM:GOTO430\r\n'
printf %s $'660 M=M\\2:IFM THEN640ELSEIFK$=" "THEN670ELSEIFK$>"0"ANDK$<"9"THENE=(E-(E MOD5))+((E+1)MOD5):GOTO430ELSE510\r\n'
printf %s $'670 IFD$<>E$THENBEEP:GOTO430ELSEIFE$<>F$THENI=I AND&HF0F\r\n'
printf %s $'680 CLS:SCREEN1,0,1:COLOR15,4,7:LOCATE0,0,0:PRINTN$\r\n'
printf %s $'690 IFINKEY$<>""THEN690\r\n'
printf %s $'700 ERASEII,NN$:IFR=0THENSTOP\r\n'
printf %s $'710 POKE&HB000,(I AND255)+1:POKE&HA000,(I AND255)+1:IFI=(I AND255)THEN750\r\n'
printf %s $'720 T$=":\230"+CHR$(12)+CHR$(0)+"\220,"+CHR$(15)+CHR$(I AND255)+":\230"+CHR$(12)+CHR$(0)+"\200,"+CHR$(15)+CHR$(I AND255)+":\230"+CHR$(12)+"v\366,"+CHR$(15)+CHR$(17)+":\230"+CHR$(12)+"w\366,"+CHR$(15)+"\200:\212"\r\n'
printf %s $'730 T$=T$+STRING$(4,CHR$(0)):T=(PEEK(VARPTR(T$)+1)+256*PEEK(VARPTR(T$)+2))-65536!\r\n'
printf %s $'740 POKE&HF6BE,239:POKE&HF6BF,255:POKE&HF6C0,T AND255:POKE&HF6C1,((T+65536!)/256)AND255:CONT\r\n'
printf %s $'750 T$="\257\315\303"+CHR$(H0)+">"+CHR$(I)+"2"+CHR$(0)+"\2202"+CHR$(0)+"\200*"+CHR$(2)+"\200\351\311"\r\n'
printf %s $'760 DEFUSR=PEEK(VARPTR(T$)+1)+256*PEEK(VARPTR(T$)+2):PRINTUSR(0):END\r\n'
printf %s $'65520 GOTO65529\r\n'
printf %s $'65521 COLOR1,11,10:IF(PEEK(&H8000)<>65)OR(PEEK(&H8001)<>66)THEN65528\r\n'
printf %s $'65522 IFPEEK(&HFC49)<192THENPOKE&HFC49,192:POKE&HFC48,0\r\n'
printf %s $'65523 CLEAR300,PEEK(&HFC4A)+256*PEEK(&HFC4B):CLEAR\r\n'
printf %s $'65524 IFPEEK(&HF6A8)<192THENPOKE&HF6A8,192:POKE&HF6A7,0\r\n'
printf %s $'65525 IFPEEK(&HF6C3)<192THENPOKE&HF6C3,192:POKE&HF6C2,3\r\n'
printf %s $'65526 IFPEEK(&HF6C5)<192THENPOKE&HF6C5,192:POKE&HF6C4,3\r\n'
printf %s $'65527 IFPEEK(&HF6C7)<192THENPOKE&HF6C7,192:POKE&HF6C6,3\r\n'
printf %s $'65528 I%=1:COLOR15,4,7:GOTO0\r\n'
printf %s $'65529 ONERRORGOTO0\r\n'
printf %s $'\032'
) > menu.asc
rebuild-all.sh

#!/bin/bash --
# rebuild-all.sh: rebuilds "clean" zip and also constructs roms
#
# requires figlet, zip, and everything else rebuild.sh requires
#
# if you want to build headless and have Xfvb and xinit and your openmsx speaks X11, do:
#
#   xinit "$(command -v bash)" ./rebuild-all.sh -- "$( command -v Xvfb )" :99 -cc 4 -screen 0 640x480x16
#
# if you want visible but single-window GUI parts of the build and have Xephyr, xinit, xterm and
# X11 bitmap fonts, do:
#
#   ( xinit "$(command -v bash)" -c 'bash ./rebuild-all.sh 2>&1 | '`: \
#        `' tee >( LC_ALL=C xterm -fn 6x12 -fullscreen -g $(( 640/6 ))x$(( 480/12 )) +sb -b 0 '`: \
#        `' -e cat <( cat /dev/fd/0 ) )' -- "$( command -v Xephyr )" :99 -screen 640x480 )
#
# in both cases change :99 to an available X11 display if :99 is not available.

rebuild_all() {
    figlet -v | head -1 | fgrep FIGlet &&
        (
            rm -rvf pirate-multi-example.rom pirate-multi-clean pirate-multi-clean.zip ||
                (
                    sleep 1 &&
                        rm -rvf pirate-multi-example.rom pirate-multi-clean pirate-multi-clean.zip
                )
        ) &&
        mkdir pirate-multi-clean &&
        cp -v rebuild.sh rebuild-all.sh apply_ips.py basld.py boot.rom menu.asc numdebug.asc numtests.asc slot-* pirate-multi-clean &&
        (
            (
                figlet -f mini 'pirate multi' &&
                    figlet -f banner 8xxx
            ) | tr '#' '"'
        ) | tee pirate-multi-clean/banner.txt &&
        (
            cd pirate-multi-clean &&
                bash rebuild.sh
        ) &&
        mv -v pirate-multi-clean/pirate-multicart.rom pirate-multi-example.rom &&
        (
            rm -v pirate-multi-clean/*.zip pirate-multi-clean/slot-* pirate-multi-clean/all-slot*rom pirate-multi-clean/pirate*rom ||
                (
                    sleep 1 &&
                        rm -v pirate-multi-clean/*.zip pirate-multi-clean/slot-* pirate-multi-clean/all-slot*rom pirate-multi-clean/pirate*rom ||
                            (
                                sleep 1 &&
                                    rm -v pirate-multi-clean/*.zip pirate-multi-clean/slot-* pirate-multi-clean/all-slot*rom pirate-multi-clean/pirate*rom
                            )
                )
        ) &&
        zip -jm9r pirate-multi-clean{,} &&
        (
            rm -rvf pirate-multi-clean ||
                (
                    sleep 1 &&
                        rm -rvf pirate-multi-clean ||
                            (
                                sleep 1 &&
                                    rm -rvf pirate-multi-clean
                            )
                )
        ) &&
        bash rebuild.sh
    exit $?
}

rebuild_all "$@"; exit $?
rebuild.sh

#!/bin/bash --
#
# What if you have a 512KB multicart split into DIP-selectable 128KB sections that supports the Konami4 mapper?
# What if you want to put multiple games in there, and you don't mind if they are selected for mainly technical reasons?
# What if you don't mind if you only get a single BASIC game in there?
# What if you don't mind a slow and ugly text-only menu system?
# What if you don't mind wasting some space idn your ROM ?
# What if you don't mind a brittle build process full of bugs?
#
# If the answer to all of the above was "yeah, sure, why not..." then this script can help you build such a multicart ROM image!
#
#                           ...
# This script rebuilds the 8xxx multicart from parts:
#
# - slot-?0-*-7k.asc
#     These are BASIC games, stored as ASCII
#     BASIC. They must be no larger than 7920 bytes when
#     tokenized. The tokenized version will live inside a 0x?0 8KB
#     page at offset 0x10 and be mapped in the 0x8010-0x9EFF region.
#     The name will be shown in the menu upper case and with - turned into a space.
# - slot-?1-*-4k.asc
#     These are BASIC games, stored as ASCII
#     BASIC. They must be no larger than 4080 bytes when
#     tokenized. The tokenized version will live inside a 0x?1 8KB
#     page at offset 0x10 and be mapped in the 0x8010-0x8FFF region.
#     The name will be shown in the menu upper case and with - turned into a space.
# - slot-??-*-8k.rom, slot-??-*-16k.rom, slot-??-*-8k.ips, slot-??-*-16k.ips 
#     MSX ROM images. All of them must be runnable in the 0x8000-0xBFFF slot and not write to KonamiSCC or Konami4 mapper
#     register addresses. Also, they must have their entry point addresses written at offset 0x0002 right after the "AB"
#     bytes, as the menu will launch them by jumping to this address. BASIC ROM games won't work in these slots, sorry.
#
#     The -??- part in the filename is the hexadecimal lower case two-digit 8KB page number where the ROM will be placed
#     in the multicart. -?0- is reserved for the boot ROM and -?1- is reserved for the menu ROM and a BASIC game.
#
#     The names -tmp-boot- and -tmp-menu- are special and reserved, do not use them. Empty names are not allowed.
#
#     All 8KB slots in the overall 512KB ROM must be filled. Remember that 16KB games occupy two of them!
#     The name will be shown in the menu upper case and with - turned into a space.
#     If an .ips file is found with the same name it will be applied to create the version stored in the multicart.
# - menu.asc
#     This is the BASIC multicart menu, stored as ASCII. It must be no larger than 4096 bytes when tokenized.
#     A tokenization of this code will live inside each 0x?1 8KB page at offset 0x1000.
#     The program cannot use line number 0 or line numbers 65520 or above.
#     Lines 100-199 and lines 300-399 will be replaced by this script!
#     This file will be modified by this script!
# - banner.txt
#     This is the ASCII banner. Double quotes will be displayed as visible cursor block characters, character code 0xFF.
#     This will be converted into code and inserted into menu.asc.
#     This needs to fit in 13 or fewer lines of 29 or fewer characters.
# - boot.rom
#     This is the machine code boot ROM. It must be 8KB with the
#     region from 0x0010 through 0x1eff empty as it will be replaced
#     with a BASIC game in each ROM page. Bytes at offsets 0x0e and
#     0xef will be overwritten by the complement of the page number
#     and the page number, respectively.
#
#     It needs to map the menu into 0x8000 and launch it.
#
#     This one boots from 0x4000..0x7FFF.
#
#     A copy of this rom will live inside each 0x?0 8KB boot page with the final byte modified to be the page number.
#     A copy of the final byte (the page number) will live inside each 0x?D 8KB menu page at offset 0x100f.
#
# Build prerequisites:
#
# - awk (GNU version!)
# - bash
# - cut
# - diff
# - dd
# - fgrep
# - grep (GNU version!)
# - head
# - hexdump
# - ls
# - nl
# - od (GNU version!)
# - openmsx (including ROMs for Sony HB-501P and Sony HBD-F1)
# - python3
# - script (util-linux one seems to be working)
# - sed (GNU version!)
# - tr
# - wc
# - zip (Info-ZIP version!)
#
# ... probably others I forgot?
#
# The script is brittle. If it fails, try to fix it I guess?
#

bas_in_rom_prelude() {
    # This BASIC snippet is added to the BASIC menu program we prepare for
    # running from ROM.  It attempts to move BASIC's RAM usage to
    # 0xC000 and above to prevent writes to the ROM area which might
    # cause mapper state changes due to KonamiSCC/Konami4/Generic 8KB
    # mapper register switching address decoding in the 0x8000-0xBFFF
    # address range.
    #
    # It tries to move BOTTOM, TEMP, VARTAB, ARYTAB, and STREND.
    #
    # It needs to use \r\n line termination as it will be injected
    # into a TCL script with \n removed.  It needs to avoid unmatched
    # {} as it will be injected into TCL.
    #
    # Your BASIC menu should not define lines 0 or 65520-65529.
    printf '%s\r\n' \
           '0 IFI%=0THENI%=1:GOTO65521ELSEI%=0' \
           '65520 GOTO65529' \
           '65521 COLOR1,11,10:IF(PEEK(&H8000)<>65)OR(PEEK(&H8001)<>66)THEN65528' \
           '65522 IFPEEK(&HFC49)<192THENPOKE&HFC49,192:POKE&HFC48,0' \
           '65523 CLEAR300,PEEK(&HFC4A)+256*PEEK(&HFC4B):CLEAR' \
           '65524 IFPEEK(&HF6A8)<192THENPOKE&HF6A8,192:POKE&HF6A7,0' \
           '65525 IFPEEK(&HF6C3)<192THENPOKE&HF6C3,192:POKE&HF6C2,3' \
           '65526 IFPEEK(&HF6C5)<192THENPOKE&HF6C5,192:POKE&HF6C4,3' \
           '65527 IFPEEK(&HF6C7)<192THENPOKE&HF6C7,192:POKE&HF6C6,3' \
           '65528 I%=1:COLOR15,4,7:GOTO0' \
           '65529 ONERRORGOTO0'
}

scripted_openmsx() {
    : run openmsx without requiring a real TTY and attempt to prevent hangs :
    printf '[ running'
    printf ' %q' openmsx "$@"
    printf ' ]\n'
    {
        local n=20
        while test $n -gt 0 && sleep 1 && printf '\0'
        do
            if [ $n -lt 15 ]
            then
                echo -n $'\r'"[ waiting ${n}s ] " >&2
            fi
            n=$(( $n - 1 ))
        done
        if [ $n -lt 10 ]
        then
            echo $'\r'"[ no more waiting ] " >&2
        fi
    } |
        (
            exec > >(
                cat
            )
            script /dev/null \
                   --return \
                   --quiet \
                   --command 'pid=$$; ( n=22; ( while sleep 1 && [ $n -gt 0 ] && kill -0 $pid; do n=$(( $n - 1 )); done ) && kill -0 $pid && echo "[ sending signal to openmsx ]" >&2 && kill $pid ) & exec openmsx '"$(printf "%q'' " "$@")"'; exit $?'
            exit $?
        )
    local ret=$?
    if [ $ret != 0 ]
    then
        echo "[ openmsx exited with code $ret ]"
    fi
    return $ret
}

ascii_basic_crunch() {
    # attempt to slightly compact BASIC ASCII to avoid line buffer size limits
    #
    # the only implemented shortenings are:
    # 1. removal of space after initial line numbers
    # 2. replacement of some instances of PRINT with ?
    #
    # this tries to preserve "quoted things", REMarks,
    # 'remarks, and everything after DATA, CALL, and _
    #
    # input is stdin or supplied arguments, output is stdout
    cat "$@" |
        LC_ALL=C tr -d $'\r\x1a' | (
        while
            l=''
            # reads input lines including trailing spaces
            while read -r -s -N 1 c
            do
                if [ :"$c" = :$'\n' ]
                then
                    break
                fi
                l="$l$c"
            done
            test ${#l} -gt 0
        do
            n=""
            while [ :"${l#[0-9]}" != :"$l" ]
            do
                n="$n${l:0:1}"
                l="${l:1}"
            done
            if [ :"${l:0:1}" = :" " ]
            then
                l="${l:1}"
            fi
            r=""
            while [ ${#l} -gt 0 ]
            do
                x="${l:0:1}"
                l="${l:1}"
                if [ :"$x" = :'"' ]
                then
                    while [ :"${l:0:1}" != :'"' -a ${#l} -gt 0 ]
                    do
                        x="$x${l:0:1}"
                        l="${l:1}"
                    done
                    x="$x${l:0:1}"
                    l="${l:1}"
                elif [ :"$x" != :"${x//[A-Za-z]/}" ]
                then
                    while
                        y="${l:0:1}"
                        [ :"$y" != :"${y//[A-Za-z]/}" ]
                    do
                        x="$x$y"
                        l="${l:1}"
                    done
                fi
                if [ :"${x#PRINT}" != :"$x" ]
                then
                    x="?${x#PRINT}"
                fi
                if [ :"$x" = :'_' \
                      -o :"$x" = :"'" \
                      -o :"$x" != :"${x//[Rr][Ee][Mm]/}" \
                      -o :"$x" != :"${x//[Dd][Aa][Tt][Aa]/}" \
                      -o :"$x" != :"${x//[Cc][Aa][Ll][Ll]/}" \
                   ]
                then
                    x="$x$l"
                    l=''
                fi
                r="$r$x"
            done
            printf '%s\r\n' "$n$r"
        done
        printf '\x1a'
    )
}

rom_tokenize() {
    ascii_input="$1"
    tokenized_output="$2"
    tmp_ascii_output="$3"
    mkdir -p tmp-openmsx-diska &&
        ascii_basic_crunch < "$ascii_input" > tmp-openmsx-diska/input.asc &&
        ( rm -vf tmp-screen.txt || ( sleep 1 && rm -vf tmp-screen.txt ) ) &&
        scripted_openmsx \
            -machine Sony_HB-501P -ext Sony_HBD-F1 \
            -diska tmp-openmsx-diska \
            -command $'set fastforward on; set old_master_volume [set master_volume]; set master_volume 0' \
            -command $'after time 25 { type {\r keyoff:screen0,,0:color15,1,1:width40:cls\r }}' \
            -command $'after time 30 { type { load "input.asc" \r }}' \
            -command $'after time 55 { type { save "output.bas" \r }}' \
            -command $'after time 80 { type { save "output.asc", a \r }}' \
            -command $'after time 120 { set screen [get_screen]; set fp [open "tmp-screen.txt" w];puts $fp $screen; close $fp; set master_volume $old_master_volume; quit; }' &&
        (
            found="$(LC_ALL=C fgrep -a -e error -e Undefined -e Illegal -e Direct -e Ok tmp-screen.txt | LC_ALL=C tr -d '\r' | LC_ALL=C uniq -c | LC_ALL=C sed 's/  */ /g;s/  *$//;s/^  *//')"
            expected="4 Ok"
            if [ :"$found" != :"$expected" ] || ! [ -f tmp-openmsx-diska/output.bas ] || ! [ -f tmp-openmsx-diska/output.asc ]
            then
                echo 'OpenMSX screen:'
                cat tmp-screen.txt
                printf '%s: [%q]\n' found "$found" expected "$expected" >&2
                \ls -ld tmp-openmsx-diska/output.bas tmp-openmsx-diska/output.asc
                exit 1
            fi
        ) &&
        ( rm -vf tmp-screen.txt || ( sleep 1 && rm -vf tmp-screen.txt ) ) &&
        cp -v tmp-openmsx-diska/output.bas "$tokenized_output" &&
        cp -v tmp-openmsx-diska/output.asc "$tmp_ascii_output" &&
        ( rm -rvf tmp-openmsx-diska || ( sleep 1 && ( rm -rvf tmp-openmsx-diska || ( sleep 1 && rm -rvf tmp-openmsx-diska ) ) ) ) &&
        \ls -d "$tmp_ascii_output" &&
        echo ensuring "$ascii_input" re-saved with no differences &&
        diff -i -u <(
            (
                (
                    cat "$ascii_input" | LC_ALL=C tr -d $'\x1a'
                ) | LC_ALL=C sort -n
                printf '\x1a'
            ) | ascii_basic_crunch
        ) <( ascii_basic_crunch "$tmp_ascii_output" ) &&
        ( rm -v "$tmp_ascii_output" || ( sleep 1 && rm -v "$tmp_ascii_output" ) ) &&
        :
    return $?
}

rebuild() {
    : rebuild script for pirate multicart :

    echo rebuilding... &&
        echo checking script usability... &&
        script --version &&
        script --help |
            fgrep -e --command &&
        script --help |
            fgrep -e --return &&
        script --help |
            fgrep -e --quiet &&
        echo script: OK &&
        echo checking openmsx usability... &&
        scripted_openmsx --version &&
        scripted_openmsx --version |
            fgrep -e openMSX &&
        ! scripted_openmsx --this-flag-is-not-implemented &&
        echo openmsx: OK &&
        echo checking python3 usability... &&
        python3 --version |
            fgrep Python &&
        echo python3: OK &&
        echo checking awk usability... &&
        awk --version |
            fgrep GNU &&
        echo awk: OK &&
        echo checking sed usability... &&
        sed --version |
            fgrep GNU &&
        echo sed: OK &&
        echo checking grep usability... &&
        grep --version |
            fgrep GNU &&
        echo grep: OK &&
        echo checking zip usability... &&
        zip --version |
            fgrep Info-ZIP &&
        echo zip: OK &&
        echo checking hexdump usability... &&
        hexdump --version &&
        echo hexdump is OK |
            hexdump -C |
            fgrep '00000000  68 65 78 64 75 6d 70 20  69 73 20 4f 4b 0a        |hexdump is OK.|' &&
        echo hexdump: OK &&
        echo checking od usability... &&
        od --version |
            fgrep GNU &&
        echo od is OK |
            od -tx1 |
            fgrep '0000000 6f 64 20 69 73 20 4f 4b 0a' &&
        echo od: OK &&
        echo cleaning temporary and generated files... &&
        rm -vf \
           *~ \
           slot-?0-tmp-boot-8k.rom \
           slot-?1-tmp-menu-8k.rom \
           all-slots.rom \
           pirate-multicart.zip \
           pirate-multicart.rom \
           pirate-multicart-slot-?x.rom \
           tmp-menu.bas \
           tmp-menu.bld \
           tmp-menu.asc \
           tmp-all-slots.rom \
           tmp-screen.txt \
           tmp-slot-*.rom \
           tmp-slot-*.bas \
           tmp-slot-*.bld \
           tmp-slot-*.tmp &&
        ( rm -rvf tmp-openmsx-diska || ( sleep 1 && ( rm -rvf tmp-openmsx-diska || ( sleep 1 && rm -rvf tmp-openmsx-diska ) ) ) ) &&
        echo cleaning temporary and generated files: DONE &&
        echo checking openmsx Sony_HB-501P and Sony_HBD-F1 usability... &&
        ( rm -vf tmp-screen.txt || ( sleep 1 && rm -vf tmp-screen.txt ) ) &&
        scripted_openmsx \
            -machine Sony_HB-501P -ext Sony_HBD-F1 \
            -command $'set fastforward on; set old_master_volume [set master_volume]; set master_volume 0' \
            -command $'after time 15 { type {\r ?"OpenMSX: ";"OK!" \r } }' \
            -command $'after time 20 { set screen [get_screen]; set fp [open "tmp-screen.txt" w];puts $fp $screen; close $fp; set master_volume $old_master_volume; quit; }' &&
        (
            found="$(LC_ALL=C fgrep -a 'OpenMSX: OK!' tmp-screen.txt | LC_ALL=C tr -d '\r' | LC_ALL=C uniq -c | LC_ALL=C sed 's/  */ /g;s/  *$//;s/^  *//')"
            expected="1 OpenMSX: OK!"
            if [ :"$found" != :"$expected" ]
            then
                echo 'OpenMSX screen:'
                cat tmp-screen.txt
                printf '%s: [%q]\n' found "$found" expected "$expected" >&2
                exit 1
            fi
        ) &&
        ( rm -vf tmp-screen.txt || ( sleep 1 && rm -vf tmp-screen.txt ) ) &&
        echo checking openmsx Sony_HB-501P usability: OK &&
        echo checking for required file boot.rom... &&
        \ls -ld boot.rom &&
        test -f boot.rom &&
        echo should be $(( 0x2000 )) bytes &&
        test $( LC_ALL=C wc -c < boot.rom ) = $(( 0x2000 )) &&
        echo should have 00 byte at offset $(( 0x1fff )) &&
        test $( dd bs=1 skip=$(( 0x1fff )) count=1 < boot.rom | od -tx1 | awk '{print $2}' ) = 00 &&
        echo checking for required file boot.rom: OK &&
        echo checking for required file menu.asc... &&
        ls -d menu.asc &&
        test -f menu.asc &&
        echo checking for required file menu.asc: OK &&
        echo checking for required file banner.txt... &&
        ls -d banner.txt &&
        test -f banner.txt &&
        echo banner.txt must have 13 or fewer lines each with 29 or fewer characters &&
        tr -d $'\r\x1a' < banner.txt |
            LC_ALL=C sed -e 's/^\([^'$'\x01'']\|'$'\x01''.\)\{30,\}/&    <= LINE TOO LONG/' |
            nl -ba -v1 |
            LC_ALL=C sed 's/^[ \t]*14[ \t]*.*/&                                  <= TOO MANY LINES/' &&
        test $( tr -d $'\r\x1a' < banner.txt | wc -l ) -le 13 &&
        ! LC_ALL=C grep -e '^\([^'$'\x01'']\|'$'\x01''.\)\{30,\}' <(
            tr -d $'\r\x1a' < banner.txt
        ) > /dev/null &&
        echo checking for required file banner.txt: OK &&
        echo checking for required file slot-\?\?-\*.rom non-overlap... &&
        (
            printf '%s\n' slot-??-*.rom | sort | uniq -w 8 -d -D
            if [ :"$( printf '%s\n' slot-??-*.rom | sort | uniq -w 8 -d -D )" != :"" ]
            then
                echo overlapping slot ROM entries >&2
                exit 1
            fi
        ) &&
        echo checking for required files slot-\?0-\*-7k.asc... &&
        set slot-{0,1,2,3}0-*-7k.asc &&
        ls -d "$@" &&
        test -f "$1" &&
        test -f "$2" &&
        test -f "$3" &&
        test -f "$4" &&
        echo checking for required files "$*": OK &&
        echo checking for required files slot-\?1-\*-4k.asc... &&
        set slot-{0,1,2,3}1-*-4k.asc &&
        ls -d "$@" &&
        test -f "$1" &&
        test -f "$2" &&
        test -f "$3" &&
        test -f "$4" &&
        echo checking for required files "$*": OK &&
        echo updating menu.asc... &&
        (
            : ' lines 1xx and 3xx will be tossed and replaced ' :
            : ' "double quotes" in banner.txt will be replaced with character 0xFF, the visible cursor block ' :
            bas_in_rom_prelude | tr -d '\r'$'\x1a'
            LC_ALL=C sed -ne 's/^  *//;/^[^13]\|^[13][^0-9]\|^[13][0-9][^0-9]\|^[13][0-9][0-9][0-9]/ p' menu.asc |
                tr -d '\r'$'\x1a'
            (
                echo -n "DATA$(
                    printf '%s\n' slot-*.asc slot-*.rom |
                        sort |
                        grep -v -e '^slot-..-tmp-menu-8k\.rom$' -e '^slot-..-tmp-boot-8k\.rom$' |
                        sed -e 's/"/"+CHR$(34)+"/g' \
                            -e 's/^slot-\([0-9a-fA-F][0-9a-fA-F]\)-\(.*\)-\(..\|.\)k\.asc$/\&H8\1,"\2"/' \
                            -e 's/^slot-0*\([0-9a-fA-F]\|[1-9a-fA-F][0-9a-fA-F]\)-\(.*\)-\(..\|.\)k\.rom$/\&H\1,"\2"/' \
                            -e 's/-/ /g' |
                        tr 'a-z' 'A-Z'
                        echo '-1,""'
                    )" |
                    tr '\n' '/' |
                    sed -e 's_.\{,240\}/_&/DATA_g;s_\([^/]\)/\([^/]\)_\1,\2_g;s_//_/_g' |
                    tr '/' '\n'
                echo
            ) |
                LC_ALL=C grep . |
                nl -ba -v100 |
                tr '\t' ' ' |
                sed 's/^ *//'
            echo '198 RESTORE100:DIMII%(256),NN$(256):E%=0'
            echo '199 READII%(E%),NN$(E%):IFNN$(E%)<>""THENE%=E%+1:GOTO199'
            tr -d '\r'$'\x1a' < banner.txt |
                LC_ALL=C tr '"' $'\xFF' |
                LC_ALL=C sed 's/^\([^'$'\x01'']\|'$'\x01''.\)\{29,29\}$/&";/' |
                LC_ALL=C nl -ba -v300 |
                LC_ALL=C sed 's/^ *\([0-9][0-9]*\)'$'\t''/\1 PRINT"/'
        ) |
            LC_ALL=C sort -n |
            LC_ALL=C uniq |
            LC_ALL=C sed $'s/$/\r/' > tmp-menu.asc &&
        printf '\x1a' >> tmp-menu.asc &&
        (
            diff -i -u <( ascii_basic_crunch menu.asc ) <( ascii_basic_crunch tmp-menu.asc ) ||
                mv -v tmp-menu.asc menu.asc
        ) &&
        rm -vf tmp-menu.asc &&
        echo updating menu.asc: OK &&
        echo generating tokenized tmp-menu.bas... &&
        rom_tokenize menu.asc tmp-menu.bas tmp-menu.asc &&
        \ls -ld tmp-menu.bas &&
        echo should be $(( 0x1000 )) bytes or smaller &&
        test $( LC_ALL=C wc -c < tmp-menu.bas ) -le $(( 0x1000 )) &&
        dd bs=1 count=1 < tmp-menu.bas | od -tx1 | awk '{print $2}' &&
        echo should have FF byte at offset 0 &&
        test $( dd bs=1 count=1 < tmp-menu.bas | od -tx1 | awk '{print $2}' ) = ff &&
        echo generating tokenized tmp-menu.bas: OK &&
        echo testing basld de-tokenization for tmp-menu.bas and generating tmp-menu.bld... &&
        python3 basld.py 0x9000 tmp-menu.bas tmp-menu.bld tmp-menu.asc &&
        echo ensuring tmp-menu.bas de-tokenized with no differences &&
        \ls -d tmp-menu.asc &&
        diff -i -u <(
            (
                (
                    cat menu.asc | LC_ALL=C tr -d $'\x1a'
                ) | LC_ALL=C sort -n
                printf '\x1a'
            ) | ascii_basic_crunch
        ) <( ascii_basic_crunch tmp-menu.asc ) &&
        ( rm -v tmp-menu.asc || ( sleep 1 && rm -v tmp-menu.asc ) ) &&
        echo ensuring tmp-menu.bld is the same length as tmp-menu.bas &&
        \ls -ld tmp-menu.bas tmp-menu.bld &&
        test $( LC_ALL=C wc -c < tmp-menu.bas ) = $( LC_ALL=C wc -c < tmp-menu.bld ) &&
        dd bs=1 count=1 < tmp-menu.bld | od -tx1 | awk '{print $2}' &&
        echo should have 00 byte at offset 0 &&
        test $( dd bs=1 count=1 < tmp-menu.bld | od -tx1 | awk '{print $2}' ) = 00 &&
        echo testing basld de-tokenization for tmp-menu.bas and generating tmp-menu.bld: OK &&
        (
            for p in 0 1 2 3
            do
                : &&
                    : ' larger game that coexists with the boot code ' : &&
                    : &&
                    echo generating tokenized tmp-slot-${p}0.bas... &&
                    rom_tokenize slot-${p}0-*-7k.asc tmp-slot-${p}0.bas tmp-slot-${p}0.asc &&
                    echo generating tokenized tmp-slot-${p}0.bas: OK &&
                    echo checking tokenized tmp-slot-${p}0.bas... &&
                    \ls -ld tmp-slot-${p}0.bas &&
                    echo should be $(( 0x2000 - 0x100 - 0x10 )) bytes or smaller &&
                    test $( LC_ALL=C wc -c < tmp-slot-${p}0.bas ) -le $(( 0x2000 - 0x100 - 0x10 )) &&
                    dd bs=1 count=1 < tmp-slot-${p}0.bas | od -tx1 | awk '{print $2}' &&
                    echo should have FF byte at offset 0 &&
                    test $( dd bs=1 count=1 < tmp-slot-${p}0.bas | od -tx1 | awk '{print $2}' ) = ff &&
                    echo checking tokenized tmp-slot-${p}0.bas: OK &&
                    echo testing basld de-tokenization for tmp-slot-${p}0.bas and generating tmp-slot-${p}0.bld... &&
                    python3 basld.py 0x8010 tmp-slot-${p}0.bas tmp-slot-${p}0.bld tmp-slot-${p}0.tmp &&
                    echo ensuring tmp-slot-${p}0.bas de-tokenized with no differences &&
                    \ls -d tmp-slot-${p}0.tmp &&
                    diff -i -u <(
                        (
                            (
                                cat slot-${p}0-*-7k.asc | LC_ALL=C tr -d $'\x1a'
                            ) | LC_ALL=C sort -n
                            printf '\x1a'
                        ) | ascii_basic_crunch
                    ) <( ascii_basic_crunch tmp-slot-${p}0.tmp ) &&
                    ( rm -v tmp-slot-${p}0.tmp || ( sleep 1 && rm -v tmp-slot-${p}0.tmp ) ) &&
                    echo ensuring tmp-slot-${p}0.bld is the same length as tmp-slot-${p}0.bas &&
                    \ls -ld tmp-slot-${p}0.bas tmp-slot-${p}0.bld &&
                    test $( LC_ALL=C wc -c < tmp-slot-${p}0.bas ) = $( LC_ALL=C wc -c < tmp-slot-${p}0.bld ) &&
                    dd bs=1 count=1 < tmp-slot-${p}0.bld | od -tx1 | awk '{print $2}' &&
                    echo should have 00 byte at offset 0 &&
                    test $( dd bs=1 count=1 < tmp-slot-${p}0.bld | od -tx1 | awk '{print $2}' ) = 00 &&
                    echo testing basld de-tokenization for tmp-slot-${p}0.bas and generating tmp-slot-${p}0.bld: OK &&
                    : &&
                    : ' smaller game that coexists with the menu ' : &&
                    : &&
                    echo generating tokenized tmp-slot-${p}1.bas... &&
                    rom_tokenize slot-${p}1-*-4k.asc tmp-slot-${p}1.bas tmp-slot-${p}1.asc &&
                    echo generating tokenized tmp-slot-${p}1.bas: OK &&
                    echo checking tokenized tmp-slot-${p}1.bas... &&
                    \ls -ld tmp-slot-${p}1.bas &&
                    echo should be $(( 0x1000 )) bytes or smaller &&
                    test $( LC_ALL=C wc -c < tmp-slot-${p}1.bas ) -le $(( 0x1000 )) &&
                    dd bs=1 count=1 < tmp-slot-${p}1.bas | od -tx1 | awk '{print $2}' &&
                    echo should have FF byte at offset 0 &&
                    test $( dd bs=1 count=1 < tmp-slot-${p}1.bas | od -tx1 | awk '{print $2}' ) = ff &&
                    echo checking tokenized tmp-slot-${p}1.bas: OK &&
                    echo testing basld de-tokenization for tmp-slot-${p}1.bas and generating tmp-slot-${p}1.bld... &&
                    python3 basld.py 0x8010 tmp-slot-${p}1.bas tmp-slot-${p}1.bld tmp-slot-${p}1.tmp &&
                    echo ensuring tmp-slot-${p}1.bas de-tokenized with no differences &&
                    \ls -d tmp-slot-${p}1.tmp &&
                    diff -i -u <(
                        (
                            (
                                cat slot-${p}1-*-4k.asc | LC_ALL=C tr -d $'\x1a'
                            ) | LC_ALL=C sort -n
                            printf '\x1a'
                        ) | ascii_basic_crunch
                    ) <( ascii_basic_crunch tmp-slot-${p}1.tmp ) &&
                    ( rm -v tmp-slot-${p}1.tmp || ( sleep 1 && rm -v tmp-slot-${p}1.tmp ) ) &&
                    echo ensuring tmp-slot-${p}1.bld is the same length as tmp-slot-${p}1.bas &&
                    \ls -ld tmp-slot-${p}1.bas tmp-slot-${p}1.bld &&
                    test $( LC_ALL=C wc -c < tmp-slot-${p}1.bas ) = $( LC_ALL=C wc -c < tmp-slot-${p}1.bld ) &&
                    dd bs=1 count=1 < tmp-slot-${p}1.bld | od -tx1 | awk '{print $2}' &&
                    echo should have 00 byte at offset 0 &&
                    test $( dd bs=1 count=1 < tmp-slot-${p}1.bld | od -tx1 | awk '{print $2}' ) = 00 &&
                    echo testing basld de-tokenization for tmp-slot-${p}1.bas and generating tmp-slot-${p}1.bld: OK &&
                    :
                ret=$?
                if [ $ret != 0 ]
                then
                    exit $ret
                fi
            done
        ) &&
        echo generating slot-\?0-tmp-boot-8k.rom... &&
        (
            for p in 0 1 2 3
            do
                echo "$p"
                (
                    dd bs=1 count=$(( 0x0e )) < boot.rom
                    LC_ALL=C printf "$(printf '\\x%02x' $(( 0x${p}0 ^ 0xff )) $(( 0x${p}0 )) )"
                    dd bs=1 < tmp-slot-${p}0.bld
                    dd bs=1 count=$(( 0x1f00 - ( 0x10 + $( LC_ALL=C wc -c < tmp-slot-${p}0.bld ) ) )) if=/dev/zero
                    dd bs=1 skip=$(( 0x1f00 )) < boot.rom
                ) > slot-${p}0-tmp-boot-8k.rom
            done
        ) &&
        echo generating slot-\?0-tmp-boot-8k.rom: OK &&
        echo generating slot-\?1-tmp-menu-8k.rom... &&
        (
            for p in 0 1 2 3
            do
                (
                    printf 'AB\x00\x5f\0\0\0\0\x00\x90\0\0\0\0'"$(printf '\\x%02x' $(( 0x${p}1 ^ 0xff )) $(( 0x${p}1 )) )"
                    dd bs=1 < tmp-slot-${p}1.bld
                    dd bs=1 count=$(( 0x1000 - ( 0x10 + $( LC_ALL=C wc -c < tmp-slot-${p}1.bld ) ) )) if=/dev/zero
                    dd bs=1 < tmp-menu.bld
                    dd bs=1 count=$(( 0x1000 - $( LC_ALL=C wc -c < tmp-menu.bld ) )) if=/dev/zero
                ) > slot-${p}1-tmp-menu-8k.rom
            done
        ) &&
        rm -vf tmp-slot-*.bas &&
        echo generating slot-\?1-tmp-menu-8k.rom: OK &&
        rm -vf tmp-menu.bas tmp-menu.bld &&
        echo generating all-slots.rom... &&
        rm -vf tmp-all-slots.rom &&
        : > tmp-all-slots.rom &&
        (
            i=$(( 0x00 ))
            for slot in slot-*.rom
            do
                if [ :"$slot" = :"${slot/slot-$(printf %02x $i)-/}" ]
                then
                    echo "$slot found, slot-$(printf %02x $i)-* expected" >&2
                    exit 1
                fi
                tmpslot="tmp-slot-$(printf %02x $i).rom"
                if ! rm -vf "$tmpslot"
                then
                    exit $?
                fi
                if [ -f "${slot/.rom/}.ips" ]
                then
                    echo applying IPS patch
                    if ! python3 apply_ips.py "${slot/.rom/}.ips" "$slot" "$tmpslot"
                    then
                        exit $?
                    fi
                else
                    if ! cp -v "$slot" "$tmpslot"
                    then
                        exit $?
                    fi
                fi
                expected_slot_suffix="-$(printf %dk $(( $( LC_ALL=C wc -c < "$tmpslot" ) / 1024 )) ).rom"
                if [ :"$slot" = :"${slot/"$expected_slot_suffix"/}" -o $(( $( LC_ALL=C wc -c < "$tmpslot" ) % 0x2000 )) != 0 ]
                then
                    \ls -dl "$tmpslot"
                    echo "$slot found, *$expected_slot_suffix expected with size a multiple of 8KB" >&2
                    exit 1
                fi
                hexdump -C "$tmpslot" |
                    head -1
                if [ :"$slot" != :"${slot/slot-?0-tmp-boot-8k.rom/}" ] &&
                       ! hexdump -C "$tmpslot" |
                           head -1 |
                           grep -e '^00000000  41 42 .. [4567]' > /dev/null
                then
                    echo "$slot boot ROM entry point is not in the 0x4000-0x7FFF range" >&2
                    exit 1
                elif [ :"$slot" != :"${slot/slot-?1-tmp-menu-8k.rom/}" ] &&
                         ! hexdump -C "$tmpslot" |
                             head -1 |
                             grep -e '^00000000  41 42 .. .. .. .. .. ..  .. [89abAB]' > /dev/null
                then
                    echo "$slot menu ROM BASIC entry point is not in the 0x8000-0xBFFF range" >&2
                    exit 1
                elif [ :"$slot" = :"${slot/slot-?0-tmp-boot-8k.rom/}" -a :"$slot" = :"${slot/slot-?1-tmp-menu-8k.rom/}" ] &&
                         ! hexdump -C "$tmpslot" |
                             head -1 |
                             grep -e '^00000000  41 42 .. [89abAB]' > /dev/null
                then
                    echo "$slot regular ROM entry point is not in the 0x8000-0xBFFF range" >&2
                    exit 1
                fi
                i=$(( $i + ( $( LC_ALL=C wc -c < "$tmpslot" ) / 0x2000 ) ))
                if ! cat "$tmpslot" >> tmp-all-slots.rom &&
                        rm -v "$tmpslot"
                then
                    exit $?
                fi
            done
            if [ $i != $(( 0x40 )) ]
            then
                echo expected to fill $(( 0x40 )) 8KB slots but actually filled $i >&2
                exit 1
            fi
        ) &&
        (
            if [ $(( (512 * 1024) - $(cat tmp-all-slots.rom | LC_ALL=C wc -c) )) != 0 ]; then
                echo "slot contents do not sum to 512KB" >&2
                exit 1
            fi
        ) &&
        cp -v tmp-all-slots.rom all-slots.rom &&
        rm -vf tmp-all-slots.rom &&
        rm -vf slot-?0-tmp-boot-8k.rom slot-?1-tmp-menu-8k.rom &&
        echo generating all-slots.rom: OK &&
        echo generating pirate-multicart-slot-\?x.rom... &&
        (
            for p in 0 1 2 3
            do
                dd bs=$((128*1024)) count=1 skip=$p < all-slots.rom > pirate-multicart-slot-${p}x.rom
            done
        ) &&
        echo generating pirate-multicart-slot-\?x.rom: OK &&
        echo generating pirate-multicart.rom... &&
        cp -v all-slots.rom pirate-multicart.rom &&
        echo generating pirate-multicart.rom: OK &&
        rm -vf tmp-slot-*.rom tmp-slot-*.bld &&
        echo testing pirate-multicart.rom... &&
        echo ... with mapper Konami4 &&
        ( rm -vf tmp-screen.txt || ( sleep 1 && rm -vf tmp-screen.txt ) ) &&
        scripted_openmsx \
            -machine Sony_HB-501P \
            pirate-multicart.rom \
            -romtype konami4 \
            -command $'set fastforward on; set old_master_volume [set master_volume]; set master_volume 0' \
            -command $'after time 25 { set screen [get_screen]; set fp [open "tmp-screen.txt" w];puts $fp $screen; close $fp; set master_volume $old_master_volume; quit; }' &&
        (
            found="$(LC_ALL=C fgrep -a -e error -e Undefined -e Illegal -e Direct -e Ok -e DIPS tmp-screen.txt | LC_ALL=C tr -d '\r' | LC_ALL=C sed 's/  */ /g;s/  *$//;s/^  *//')"
            expected="DIPS 0000=0000"
            if [ :"$found" != :"$expected" ]
            then
                echo 'OpenMSX screen:'
                cat tmp-screen.txt
                printf '%s: [%q]\n' found "$found" expected "$expected" >&2
                exit 1
            fi
        ) &&
        ( rm -vf tmp-screen.txt || ( sleep 1 && rm -vf tmp-screen.txt ) ) &&
        echo ... with mapper KonamiSCC &&
        scripted_openmsx \
            -machine Sony_HB-501P \
            pirate-multicart.rom \
            -romtype konamiscc \
            -command $'set fastforward on; set old_master_volume [set master_volume]; set master_volume 0' \
            -command $'after time 25 { set screen [get_screen]; set fp [open "tmp-screen.txt" w];puts $fp $screen; close $fp; set master_volume $old_master_volume; quit; }' &&
        (
            found="$(LC_ALL=C fgrep -a -e error -e Undefined -e Illegal -e Direct -e Ok -e DIPS tmp-screen.txt | LC_ALL=C tr -d '\r' | LC_ALL=C sed 's/  */ /g;s/  *$//;s/^  *//')"
            expected="DIPS 0000=0000"
            if [ :"$found" != :"$expected" ]
            then
                echo 'OpenMSX screen:'
                cat tmp-screen.txt
                printf '%s: [%q]\n' found "$found" expected "$expected" >&2
                exit 1
            fi
        ) &&
        ( rm -vf tmp-screen.txt || ( sleep 1 && rm -vf tmp-screen.txt ) ) &&
        echo testing pirate-multicart.rom: OK &&
        (
            for p in 0 1 2 3
            do
                echo testing pirate-multicart-slot-${p}x.rom... &&
                    ( rm -vf tmp-screen.txt || ( sleep 1 && rm -vf tmp-screen.txt ) ) &&
                    scripted_openmsx \
                        -machine Sony_HB-501P \
                        pirate-multicart-slot-${p}x.rom \
                        -romtype 8kb \
                        -command $'set fastforward on; set old_master_volume [set master_volume]; set master_volume 0' \
                        -command $'after time 25 { set screen [get_screen]; set fp [open "tmp-screen.txt" w];puts $fp $screen; close $fp; set master_volume $old_master_volume; quit; }' &&
                    (
                        found="$(LC_ALL=C fgrep -a -e error -e Undefined -e Illegal -e Direct -e Ok -e DIPS tmp-screen.txt | LC_ALL=C tr -d '\r' | LC_ALL=C sed 's/  */ /g;s/  *$//;s/^  *//')"
                        pdips="$(python3 -c 'import sys; _, p = sys.argv; print(bin(0x100 | int(p) )[-4:])' $p)"
                        expected="DIPS $pdips=$pdips"
                        if [ :"$found" != :"$expected" ]
                        then
                            echo 'OpenMSX screen:'
                            cat tmp-screen.txt
                            printf '%s: [%q]\n' found "$found" expected "$expected" >&2
                            exit 1
                        fi
                    ) &&
                    ( rm -vf tmp-screen.txt || ( sleep 1 && rm -vf tmp-screen.txt ) ) &&
                    echo testing pirate-multicart-slot-${p}x.rom: OK
                ret=$?
                if [ $ret != 0 ]
                then
                    exit $ret
                fi
            done
        ) &&
        echo generating pirate-multicart.zip... &&
        zip -j9r pirate-multicart.zip . &&
        echo generating pirate-multicart.zip: OK &&
        echo rebuilding: OK
    exit $?
}

rebuild "$@"; exit $?
basld.py

#!/usr/bin/env python3

from collections import namedtuple

import codecs
import os.path
import struct
import sys

RamRelocation = namedtuple('RamRelocation', ('relocation_offset', 'referenced_line_pointer', 'containing_line', 'relocation_text_offset', 'relocation_text_token'))

RomRelocation = namedtuple('RomRelocation', ('relocation_offset', 'referenced_line', 'containing_line'))

def basfloat_to_str(b):
    """
    Converts BASIC BCD floating-point to string.
    It will blindly convert values that do not round-trip or aren't even BCD, similarly to STR$().
    If too few bytes are given it will pad with 0x00 bytes.
    Some of the returned conversions containing 'E' are ambiguous as to whether the number was stored as single-precision or double-precision.
    We could show exponent -65 as plain unsigned zero as BASIC sometimes does, but choose not to so that data may be seen less ambiguously.
    """
    while len(b) < 8 and len(b) != 4:
        b += b'\x00'
    assert len(b) in (4, 8)
    format_disambiguator = '!#'[len(b) == 8]
    sign_and_biased_exponent, hex_mantissa = ord(b[:1]), codecs.encode(b[1:], 'hex').decode('iso-8859-1')
    sign_prefix = '-'[:sign_and_biased_exponent >= 0x80]
    exponent = (sign_and_biased_exponent & 0x7f) - 65
    decimal_mantissa = ''.join(chr(0x30 + int(digit, 16)) for digit in hex_mantissa)
    if exponent > -3 and exponent < 14:
        decimal_mantissa, exponent = ('000'+decimal_mantissa+'00000000000000')[:4+exponent] + '.' + ('000'+decimal_mantissa+'00000000000000')[4+exponent:], 0
        while decimal_mantissa[:1] == '0':
            decimal_mantissa = decimal_mantissa[1:]
        while decimal_mantissa[-1:] == '0':
            decimal_mantissa = decimal_mantissa[:-1]
    else:
        decimal_mantissa = decimal_mantissa[:1] + '.' + decimal_mantissa[1:]
    while decimal_mantissa[-1:] == '0' and '.' in decimal_mantissa:
        decimal_mantissa = decimal_mantissa[:-1]
    if decimal_mantissa[-1:] == '.':
        decimal_mantissa = decimal_mantissa[:-1]
    if decimal_mantissa == '0' and sign_prefix == '':
        exponent = 0
    while exponent != 0 and len(''.join(decimal_mantissa.lstrip('0').split('.'))) < 7 and format_disambiguator == '#':
        if '.' not in decimal_mantissa:
            decimal_mantissa += '.'
        decimal_mantissa += '0'
    return sign_prefix + decimal_mantissa + (('E' + '-+'[exponent > 0] + ('%02d' % abs(exponent))) if exponent != 0 else format_disambiguator[:('.' not in decimal_mantissa) or (format_disambiguator == '#')])

def test_basfloat():
    basfloat_test_expectations = {
        '00000000': '0!',
        '0000000000000000': '0#',
        '0000000000000001': '0.0000000000001E-65',
        '00000001': '0.00001E-65',
        '0000000100000000': '0.0000100E-65',
        '00100000': '1E-65',
        '0010000000000000': '1.000000E-65',
        '01100000': '1E-64',
        '0110000000000000': '1.000000E-64',
        '01234567': '2.34567E-64',
        '0123456700000000': '2.345670E-64',
        '0123456789ABCDEF': '2.3456789:;<=>?E-64',
        '11111111': '1.11111E-48',
        '1111111100000000': '1.111110E-48',
        '1111111111111111': '1.1111111111111E-48',
        '2020202020202020': '2.020202020202E-33',
        '3E100000': '1E-03',
        '3E10000000000000': '1.000000E-03',
        '3E999999': '9.99999E-03',
        '3E99999900000000': '9.999990E-03',
        '3E99999999999999': '9.9999999999999E-03',
        '3F100000': '.01',
        '3F10000000000000': '.01#',
        '40100000': '.1',
        '4010000000000000': '.1#',
        '40999999': '.999999',
        '4099999900000000': '.999999#',
        '4099999999999999': '.99999999999999#',
        '41100000': '1!',
        '4110000000000000': '1#',
        '41900000': '9!',
        '4190000000000000': '9#',
        '41999999': '9.99999',
        '4199999900000000': '9.99999#',
        '4199999999999999': '9.9999999999999#',
        '43123123': '123.123',
        '4312312300000000': '123.123#',
        '4312312345678901': '123.12345678901#',
        '46123456': '123456!',
        '4612345600000000': '123456#',
        '4612345612345678': '123456.12345678#',
        '46999999': '999999!',
        '4699999900000000': '999999#',
        '47100000': '1000000!',
        '4710000000000000': '1000000#',
        '4710000010000000': '1000001#',
        '4E100000': '10000000000000!',
        '4E10000000000000': '10000000000000#',
        '4E999999': '99999900000000!',
        '4E99999900000000': '99999900000000#',
        '4E99999999999999': '99999999999999#',
        '4F100000': '1E+14',
        '4F10000000000000': '1.000000E+14',
        '4F10000000000001': '1.0000000000001E+14',
        '60272C2E60272C2E': '2.72<2>60272<2>E+31',
        '7975636B': '7.5636;E+56',
        '7F7F7F7F': '7.?7?7?E+62',
        '7F7F7F7F00000000': '7.?7?7?0E+62',
        '7F7F7F7F7F7F7F7F': '7.?7?7?7?7?7?7?E+62',
        '7F999999': '9.99999E+62',
        '7F99999900000000': '9.999990E+62',
        '7F99999999999999': '9.9999999999999E+62',
        '7FFFFFFF': '?.?????E+62',
        '7FFFFFFF00000000': '?.?????0E+62',
        '7FFFFFFFFFFFFFFF': '?.?????????????E+62',
        '80000000': '-0E-65',
        '8000000000000000': '-0.0000000E-65',
        '8000000000000001': '-0.0000000000001E-65',
        '80000001': '-0.00001E-65',
        '8000000100000000': '-0.0000100E-65',
        '80100000': '-1E-65',
        '8010000000000000': '-1.000000E-65',
        '81100000': '-1E-64',
        '8110000000000000': '-1.000000E-64',
        '99999999': '-9.99999E-40',
        '9999999900000000': '-9.999990E-40',
        '9999999999999999': '-9.9999999999999E-40',
        'BE100000': '-1E-03',
        'BE10000000000000': '-1.000000E-03',
        'BE999999': '-9.99999E-03',
        'BE99999900000000': '-9.999990E-03',
        'BE99999999999999': '-9.9999999999999E-03',
        'BF100000': '-.01',
        'BF10000000000000': '-.01#',
        'C0100000': '-.1',
        'C010000000000000': '-.1#',
        'C0999999': '-.999999',
        'C099999900000000': '-.999999#',
        'C099999999999999': '-.99999999999999#',
        'C1100000': '-1!',
        'C110000000000000': '-1#',
        'C1900000': '-9!',
        'C190000000000000': '-9#',
        'C1999999': '-9.99999',
        'C199999900000000': '-9.99999#',
        'C199999999999999': '-9.9999999999999#',
        'C3123123': '-123.123',
        'C312312300000000': '-123.123#',
        'C312312345678901': '-123.12345678901#',
        'C6123456': '-123456!',
        'C612345600000000': '-123456#',
        'C612345612345678': '-123456.12345678#',
        'C6999999': '-999999!',
        'C699999900000000': '-999999#',
        'C7100000': '-1000000!',
        'C710000000000000': '-1000000#',
        'C710000010000000': '-1000001#',
        'CCCCCCCCCCCCCCCC': '-<<<<<<<<<<<<.<<#',
        'CE100000': '-10000000000000!',
        'CE10000000000000': '-10000000000000#',
        'CE999999': '-99999900000000!',
        'CE99999900000000': '-99999900000000#',
        'CE99999999999999': '-99999999999999#',
        'CF100000': '-1E+14',
        'CF10000000000000': '-1.000000E+14',
        'CF10000000000001': '-1.0000000000001E+14',
        'FF999999': '-9.99999E+62',
        'FF99999900000000': '-9.999990E+62',
        'FF99999999999999': '-9.9999999999999E+62',
        'FFFFFFFF': '-?.?????E+62',
        'FFFFFFFF00000000': '-?.?????0E+62',
        'FFFFFFFFFFFFFFFF': '-?.?????????????E+62',
    }
    basfloat_test_failures = {
        basfloat_hex: results
    for (basfloat_hex, results) in
        {
            basfloat_hex: dict(
                actual=basfloat_to_str(codecs.decode(basfloat_hex, 'hex')),
                expected=expected,
            )
        for (basfloat_hex, expected) in basfloat_test_expectations.items()
        }.items()
    if results['actual'] != results['expected']
    }
    assert not basfloat_test_failures, basfloat_test_failures

def basld(load_addr, bas, verbose = True):
    """
    Converts BASIC token stream from serialized format to runtime
    format relocated to the given load address, and also outputs a
    text serialization. In can also relocate a token stream that is
    already in memory format.
    """
    assert load_addr == int(load_addr)
    load_addr = int(load_addr)
    assert load_addr >= 0x8000
    assert load_addr < 0xFFFF
    assert bas[:1] in b'\x00\xff' # sanity check: serialized tokenized BASIC on disk starts with a single 0xFF byte; in memory it starts with a single 0x00 byte
    line_map = {}
    line_unmap = {}
    ram_relocations = []
    rom_relocations = []
    ram_start = None
    ram_address = None
    previous_line_number = None
    previous_line_start = 0
    bld = b'\x00' # tokenized BASIC loaded into RAM or ROM always begins with a single 0x00 byte
    text = ''
    while True:
        next_ram_address, = struct.unpack('<H', bas[len(bld):2+len(bld)])
        if ram_address is not None:
            previous_ram_address = ram_address - (len(bld) - previous_line_start)
            if ram_start is None:
                ram_start = previous_ram_address - len(bld)
            line_unmap[previous_ram_address - 1] = previous_line_number
        if next_ram_address == 0x0000:
            bld += struct.pack('<H', next_ram_address)
            if (len(bas) > len(bld)) and bas[:1] == '\xff':
                print('Extra bytes after token stream in serialized tokenized BASIC disk format')
            bld += bas[len(bld):]
            text += '\x1a'
            break
        assert next_ram_address >= 0x8000 and next_ram_address < 0xFFFF, "next_ram_address = 0x%(next_ram_address)x should be 0x8000 or higher" % {'next_ram_address': next_ram_address}
        if ram_address is not None:
            assert next_ram_address > ram_address
        line_number, = struct.unpack('<H', bas[2+len(bld):4+len(bld)])
        text += str(line_number) + ' '
        if previous_line_number is not None:
            assert line_number >= previous_line_number
        previous_line_number = line_number
        previous_line_start = len(bld)
        line_map[line_number] = len(bld) - 1
        offset = 4+len(bld)
        reference_type = None
        multiple_reference_possible = False
        do_not_resolve = False
        zero_means_off = False
        while True:
            token = bas[offset:1+offset]
            if bas[:1] == b'\xFF':
                assert token != b'\x0D' # RAM relocation should not be present in serialized input
            offset += 1
            if token == b':':
                reference_type = None
                multiple_reference_possible = False
                do_not_resolve = False
                zero_means_off = False
            if token == b'\xFF':
                token += bas[offset:1+offset]
                offset += 1
            elif token == b':' and bas[offset:offset+2] == b'\x8f\xe6':
                token += bas[offset:2+offset]
                offset += 2
            elif token == b':' and bas[offset:offset+1] == b'\xa1':
                token += bas[offset:1+offset]
                offset += 1
            elif token == b'\xa1':
                text += '\b' # not quite right, but as close as we can easily get
            text_token = {
                b'\x00': '\r\n',
                b'\x0B': '&O%o' % struct.unpack('<H', bas[offset:2+offset]),
                b'\x0C': '&H%X' % struct.unpack('<H', bas[offset:2+offset]),
                b'\x0D': '\N{right-pointing magnifying glass}\N{fullwidth left white parenthesis}@ 0x%X\N{fullwidth right white parenthesis}' % struct.unpack('<H', bas[offset:2+offset]),
                b'\x0E': '%u' % struct.unpack('<H', bas[offset:2+offset]),
                b'\x0F': '%u' % ord(bas[offset:1+offset]),
                b'\x11': '0',
                b'\x12': '1',
                b'\x13': '2',
                b'\x14': '3',
                b'\x15': '4',
                b'\x16': '5',
                b'\x17': '6',
                b'\x18': '7',
                b'\x19': '8',
                b'\x1a': '9',
                b'\x1c': '%d' % struct.unpack('<h', bas[offset:2+offset]),
                b'\x1d': basfloat_to_str(bas[offset:4+offset]),
                b'\x1f': basfloat_to_str(bas[offset:8+offset]),
                b':\x8F\xE6': "'",
                b':\xA1': 'ELSE',
                b'\x81': 'END',
                b'\x82': 'FOR',
                b'\x83': 'NEXT',
                b'\x84': 'DATA',
                b'\x85': 'INPUT',
                b'\x86': 'DIM',
                b'\x87': 'READ',
                b'\x88': 'LET',
                b'\x89': 'GOTO',
                b'\x8A': 'RUN',
                b'\x8B': 'IF',
                b'\x8C': 'RESTORE',
                b'\x8D': 'GOSUB',
                b'\x8E': 'RETURN',
                b'\x8F': 'REM',
                b'\x90': 'STOP',
                b'\x91': 'PRINT',
                b'\x92': 'CLEAR',
                b'\x93': 'LIST',
                b'\x94': 'NEW',
                b'\x95': 'ON',
                b'\x96': 'WAIT',
                b'\x97': 'DEF',
                b'\x98': 'POKE',
                b'\x99': 'CONT',
                b'\x9A': 'CSAVE',
                b'\x9B': 'CLOAD',
                b'\x9C': 'OUT',
                b'\x9D': 'LPRINT',
                b'\x9E': 'LLIST',
                b'\x9F': 'CLS',
                b'\xA0': 'WIDTH',
                b'\xA1': 'ELSE', # this should not happen, b':\xA1' is the canonical form
                b'\xA2': 'TRON',
                b'\xA3': 'TROFF',
                b'\xA4': 'SWAP',
                b'\xA5': 'ERASE',
                b'\xA6': 'ERROR',
                b'\xA7': 'RESUME',
                b'\xA8': 'DELETE',
                b'\xA9': 'AUTO',
                b'\xAA': 'RENUM',
                b'\xAB': 'DEFSTR',
                b'\xAC': 'DEFINT',
                b'\xAD': 'DEFSNG',
                b'\xAE': 'DEFDBL',
                b'\xAF': 'LINE',
                b'\xB0': 'OPEN',
                b'\xB1': 'FIELD',
                b'\xB2': 'GET',
                b'\xB3': 'PUT',
                b'\xB4': 'CLOSE',
                b'\xB5': 'LOAD',
                b'\xB6': 'MERGE',
                b'\xB7': 'FILES',
                b'\xB8': 'LSET',
                b'\xB8': 'LSET',
                b'\xB9': 'RSET',
                b'\xBA': 'SAVE',
                b'\xBB': 'LFILES',
                b'\xBC': 'CIRCLE',
                b'\xBD': 'COLOR',
                b'\xBE': 'DRAW',
                b'\xBF': 'PAINT',
                b'\xC0': 'BEEP',
                b'\xC1': 'PLAY',
                b'\xC2': 'PSET',
                b'\xC3': 'PRESET',
                b'\xC4': 'SOUND',
                b'\xC5': 'SCREEN',
                b'\xC6': 'VPOKE',
                b'\xC7': 'SPRITE',
                b'\xC8': 'VDP',
                b'\xC9': 'BASE',
                b'\xCA': 'CALL',
                b'\xCB': 'TIME',
                b'\xCC': 'KEY',
                b'\xCD': 'MAX',
                b'\xCE': 'MOTOR',
                b'\xCF': 'BLOAD',
                b'\xD0': 'BSAVE',
                b'\xD1': 'DSKO$',
                b'\xD2': 'SET',
                b'\xD3': 'NAME',
                b'\xD4': 'KILL',
                b'\xD5': 'IPL',
                b'\xD6': 'COPY',
                b'\xD7': 'CMD',
                b'\xD8': 'LOCATE',
                b'\xD9': 'TO',
                b'\xDA': 'THEN',
                b'\xDB': 'TAB(',
                b'\xDC': 'STEP',
                b'\xDD': 'USR',
                b'\xDE': 'FN',
                b'\xDF': 'SPC(',
                b'\xE0': 'NOT',
                b'\xE1': 'ERL',
                b'\xE2': 'ERR',
                b'\xE3': 'STRING$',
                b'\xE4': 'USING',
                b'\xE5': 'INSTR',
                b'\xE7': 'VARPTR',
                b'\xE8': 'CSRLIN',
                b'\xE9': 'ATTR$',
                b'\xEA': 'DSKI$',
                b'\xEB': 'OFF',
                b'\xEC': 'INKEY$',
                b'\xED': 'POINT',
                b'\xEE': '>',
                b'\xEF': '=',
                b'\xF0': '<',
                b'\xF1': '+',
                b'\xF2': '-',
                b'\xF3': '*',
                b'\xF4': '/',
                b'\xF5': '^',
                b'\xF6': 'AND',
                b'\xF7': 'OR',
                b'\xF8': 'XOR',
                b'\xF9': 'EQV',
                b'\xFA': 'IMP',
                b'\xFB': 'MOD',
                b'\xFC': '\\',
                b'\xFF\x81': 'LEFT$',
                b'\xFF\x82': 'RIGHT$',
                b'\xFF\x83': 'MID$',
                b'\xFF\x84': 'SGN',
                b'\xFF\x85': 'INT',
                b'\xFF\x86': 'ABS',
                b'\xFF\x87': 'SQR',
                b'\xFF\x88': 'RND',
                b'\xFF\x89': 'SIN',
                b'\xFF\x8A': 'LOG',
                b'\xFF\x8B': 'EXP',
                b'\xFF\x8C': 'COS',
                b'\xFF\x8D': 'TAN',
                b'\xFF\x8E': 'ATN',
                b'\xFF\x8F': 'FRE',
                b'\xFF\x90': 'INP',
                b'\xFF\x91': 'POS',
                b'\xFF\x92': 'LEN',
                b'\xFF\x93': 'STR$',
                b'\xFF\x94': 'VAL',
                b'\xFF\x95': 'ASC',
                b'\xFF\x96': 'CHR$',
                b'\xFF\x97': 'PEEK',
                b'\xFF\x98': 'VPEEK',
                b'\xFF\x99': 'SPACE$',
                b'\xFF\x9A': 'OCT$',
                b'\xFF\x9B': 'HEX$',
                b'\xFF\x9C': 'LPOS',
                b'\xFF\x9D': 'BIN$',
                b'\xFF\x9E': 'CINT',
                b'\xFF\x9F': 'CSNG',
                b'\xFF\xA0': 'CDBL',
                b'\xFF\xA1': 'FIX',
                b'\xFF\xA2': 'STICK',
                b'\xFF\xA3': 'STRIG',
                b'\xFF\xA4': 'PDL',
                b'\xFF\xA5': 'PAD',
                b'\xFF\xA6': 'DSKF',
                b'\xFF\xA7': 'FPOS',
                b'\xFF\xA8': 'CVI',
                b'\xFF\xA9': 'CVS',
                b'\xFF\xAA': 'CVD',
                b'\xFF\xAB': 'EOF',
                b'\xFF\xAC': 'LOC',
                b'\xFF\xAD': 'LOF',
                b'\xFF\xAE': 'MKI$',
                b'\xFF\xAF': 'MKS$',
                b'\xFF\xB0': 'MKD$',
            }.get(token, token.decode('iso-8859-1'))
            text += text_token
            is_possible_reference = False
            next_reference_type = None
            if text_token == '\r\n':
                # end of line
                break
            elif text_token == 'ON':
                multiple_reference_possible = True
                do_not_resolve = False
            elif text_token == 'SPRITE' and multiple_reference_possible:
                # ON SPRITE GOSUB does not work with resolved line numbers
                do_not_resolve = True
            elif text_token == 'ERROR':
                if multiple_reference_possible:
                    multiple_reference_possible = False
                    zero_means_off = True
            elif text_token == ' ':
                next_reference_type = reference_type
            elif text_token == ',':
                next_reference_type = reference_type if multiple_reference_possible else None
            elif (text_token in ('REM', "'")) and (token != b"'"):
                while bas[offset:1+offset] != b'\x00':
                    text += chr(ord(bas[offset:1+offset]))
                    offset += 1
            elif text_token in ('_', 'CALL', 'DATA'):
                # note that regular parsing of DATA and READ's parsing
                # of DATA work differently. this tries to mimic
                # regular parsing.
                while bas[offset:1+offset] not in b'\x00:':
                    text += chr(ord(bas[offset:1+offset]))
                    offset += 1
                    if text[-1:] == '"':
                        while bas[offset:1+offset] not in b'\x00"':
                            text += chr(ord(bas[offset:1+offset]))
                            offset += 1
                        if bas[offset:1+offset] == b'"':
                            text += '"'
                            offset += 1
            elif token == b'"':
                while bas[offset:1+offset] not in b'\x00"':
                    text += chr(ord(bas[offset:1+offset]))
                    offset += 1
                if bas[offset:1+offset] == b'"':
                    text += '"'
                    offset += 1
            elif token in b'\x0B\x0C\x1C':
                assert reference_type is None # not a line number reference
                # non-line number integer in word format. signed, but non-decimal bases are displayed unsigned.
                offset += 2
            elif token == b'\x0D':
                assert reference_type is not None # line number reference (RAM)
                line_pointer_value, = struct.unpack('<H', bas[offset:2+offset])
                offset += 2
                ram_relocations.append(RamRelocation(relocation_offset=offset-3, referenced_line_pointer=line_pointer_value, containing_line=line_number, relocation_text_offset=len(text) - len(text_token), relocation_text_token=text_token))
                next_reference_type = reference_type if multiple_reference_possible else None # some reference tokens allow multiple line numbers with commas
            elif token == b'\x0E':
                assert reference_type is not None # line number reference (unresolved)
                decimal_unsigned_integer_value, = struct.unpack('<H', bas[offset:2+offset])
                offset += 2
                if (reference_type == 'RESTORE') or do_not_resolve or (zero_means_off and decimal_unsigned_integer_value == 0):
                    # RESTORE references do not work when resolved
                    # ON SPRITE GOSUB references do not work when resolved
                    # ON ERROR GOTO 0 does not actually jump to zero even if line 0 exists
                    pass
                else:
                    rom_relocations.append(RomRelocation(relocation_offset=offset-3, referenced_line=decimal_unsigned_integer_value, containing_line=line_number))
                next_reference_type = reference_type if multiple_reference_possible else None # some reference tokens allow multiple line numbers with commas
            elif token in b'\x0F':
                assert reference_type is None # not a line number reference
                # non-line number unsigned integer in unsigned-word format
                offset += 1
            elif token >= b'\x11' and token <= b'\x1A':
                assert reference_type is None # not a line number reference
                # small decimal unsigned integer in bias-0x11 format
            elif token == b'\x1D':
                assert reference_type is None # not a line number reference
                # four-byte single-precision float
                offset += 4
            elif token == b'\x1F':
                assert reference_type is None # not a line number reference
                # eight-byte double-precision float
                offset += 8
            elif text_token in (
                    'AUTO',
                    'DELETE',
                    'ELSE',
                    'GOSUB',
                    'GOTO',
                    'LIST',
                    'LLIST',
                    'RENUM',
                    'RESTORE',
                    'RESUME',
                    'RETURN',
                    'RUN',
                    'THEN',
            ):
                # tokens possibly followed by one or more line references
                next_reference_type = text_token
            reference_type = next_reference_type
            pass
        assert text.endswith('\r\n')
        if ram_address is None:
            ram_address = next_ram_address - (offset - len(bld))
        if ram_start is None:
            ram_start = ram_address - len(bld)
        for i in range(len(ram_relocations))[::-1]:
            relocation_offset, referenced_line_pointer, containing_line, relocation_text_offset, relocation_text_token = ram_relocations[i] # process last-to-first to simplify text patching
            if containing_line != line_number:
                break
            if referenced_line_pointer < ram_start or referenced_line_pointer > (ram_start + len(bas) - 3):
                continue
            resolved_line, = struct.unpack('<H', bas[referenced_line_pointer - ram_start + 3:][:2])
            if referenced_line_pointer in line_unmap:
                assert resolved_line == line_unmap[referenced_line_pointer]
            old_relocation_text_token = relocation_text_token
            relocation_text_token = str(resolved_line)
            text = text[:relocation_text_offset] + relocation_text_token + text[relocation_text_offset + len(old_relocation_text_token):]
            relocation_text_token_size_delta = len(relocation_text_token) - len(old_relocation_text_token)
            ram_relocations[i] = ram_relocations[i]._replace(relocation_text_token=relocation_text_token)
            for j in range(i + 1, len(ram_relocations)):
                ram_relocations[j] = ram_relocations[j]._replace(relocation_text_offset=ram_relocations[j].relocation_text_offset + relocation_text_token_size_delta)
        if verbose:
            print(('0x%04X' + ['\N{rightwards arrow}0x%04X' % (load_addr + len(bld)), ''][ram_address == (load_addr + len(bld))] + ':') % ram_address, text.split('\r\n')[-2])
        line_unmap[(ram_address if ram_address is not None else next_ram_address - offset) - 1] = line_number
        if ram_address is not None:
            assert next_ram_address == ram_address + (offset - len(bld)), 'next_ram_address 0x%(next_ram_address)x should be == 0x%(expected_next_ram_address)x, i.e. ram_address 0x%(ram_address)x + (%(delta)x, i.e. offset 0x%(offset)x - len(bld) 0x%(len_bld)x)' % dict(next_ram_address=next_ram_address, expected_next_ram_address=ram_address + (offset - len(bld)), ram_address=ram_address, delta=offset - len(bld), offset=offset, len_bld=len(bld))
        ram_address = next_ram_address
        bld += struct.pack('<HH', offset + load_addr, line_number) + bas[4+len(bld):offset]
    assert len(bas) == len(bld)
    unresolved_ram_relocations = 0
    while len(ram_relocations):
        relocation_offset, referenced_line_pointer, containing_line, relocation_text_offset, relocation_text_token = ram_relocations.pop() # process last-to-first to simplify text patching
        assert ram_start is not None
        if referenced_line_pointer not in line_unmap:
            print('Undefined line reference &H%(referenced_line_pointer)X (%(referenced_line_pointer)d) in %(containing_line)d' % dict(referenced_line_pointer=referenced_line_pointer, containing_line=containing_line))
            unresolved_ram_relocations += 1
            continue
        resolved_line = line_unmap[referenced_line_pointer]
        rom_relocations.append(RomRelocation(relocation_offset=relocation_offset, referenced_line=resolved_line, containing_line=containing_line))
        bld=bld[:relocation_offset] + b'\x0E' + struct.pack('<H', resolved_line) + bld[3+relocation_offset:]
        text = text[:relocation_text_offset] + str(resolved_line) + text[relocation_text_offset + len(relocation_text_token):]
    assert unresolved_ram_relocations == 0, '%(unresolved_ram_relocations)d unresolved RAM relocations' % dict(unresolved_ram_relocations=unresolved_ram_relocations)
    unresolved_rom_relocations = 0
    for rom_relocation in rom_relocations:
        relocation_offset, referenced_line, containing_line = rom_relocation
        if referenced_line not in line_map:
            print('Undefined line %(referenced_line)d in %(containing_line)d' % dict(referenced_line=referenced_line, containing_line=containing_line))
            unresolved_rom_relocations += 1
            continue
        resolved_rom_address = load_addr + line_map[referenced_line]
        bld=bld[:relocation_offset] + b'\x0D' + struct.pack('<H', resolved_rom_address) + bld[3+relocation_offset:]
    if unresolved_rom_relocations > 0:
        print('Warning: %(unresolved_rom_relocations)d unresolved ROM relocations' % dict(unresolved_rom_relocations=unresolved_rom_relocations))
    return bld, text

def main():
    optional_verbose_flag = None
    try:
        prog_name, optional_verbose_flag, load_addr_hex, bas_file_name, bld_file_name, txt_file_name = sys.argv
        assert optional_verbose_flag in ('-v', '-verbose', '--verbose')
    except:
        prog_name, load_addr_hex, bas_file_name, bld_file_name, txt_file_name = sys.argv
    verbose = optional_verbose_flag is not None
    load_addr = int(load_addr_hex, 16)
    bas = open(bas_file_name, "rb").read()
    bld, text = basld(load_addr, bas, verbose = verbose)
    assert len(bld) == len(bas)
    bld2, text2 = basld(load_addr, bld, verbose = False)
    assert bld2 == bld # loading twice to the same address should not change the binary output
    assert text2 == text # loading twice to the same address should not change the text output
    open(bld_file_name, "wb").write(bld)
    open(txt_file_name, "wb").write(text.encode('iso-8859-1'))

if __name__ == "__main__":
    test_basfloat()
    main()
apply_ips.py

#!/usr/bin/env python3
# -*- python -*-

import os, sys

def apply_ips(patch, original, force = False):
    IPS_MAGIC = b'PATCH'
    IPS_EOF = b'EOF'
    if not force: assert patch != IPS_MAGIC + IPS_EOF  # Don't apply empty patch
    assert patch[:len(IPS_MAGIC)] == IPS_MAGIC
    assert (patch[-len(IPS_EOF):] == IPS_EOF or patch[-(len(IPS_EOF) + 3):-3] == IPS_EOF)
    changed = original
    BAD_OFFSET = (IPS_EOF[0] << 16) | (IPS_EOF[1] << 8) | IPS_EOF[2]
    cursor = len(IPS_MAGIC) - len(patch)
    next_offset = 0
    while cursor < 0:
        assert cursor <= -3
        block_offset = (patch[cursor] << 16) | (patch[cursor + 1] << 8) | patch[cursor + 2]
        if cursor in (-len(IPS_EOF), -(len(IPS_EOF) + 3)):
            assert block_offset == BAD_OFFSET
            cursor += len(IPS_EOF)
            if cursor == -3:
                truncate_length = (patch[cursor] << 16) | (patch[cursor + 1] << 8) | patch[cursor + 2]
                if not force: assert truncate_length >= next_offset  # Don't truncate patched parts
                if not force: assert len(changed) >= truncate_length  # Too short to truncate
                changed = changed[:truncate_length]
                cursor = 0
            break
        assert patch[cursor:cursor + len(IPS_EOF)] != IPS_EOF
        if not force: assert block_offset >= next_offset  # No out-of-order blocks
        if not force: assert block_offset <= len(changed)  # No unmapped gaps
        cursor += 3
        assert cursor <= -(3 + len(IPS_EOF))  # Space for length + byte + EOF
        block_length = (patch[cursor] << 8) | patch[cursor + 1]
        cursor += 2
        if block_length == 0:
            assert cursor <= -(3 + len(IPS_EOF))  # Space for run length + byte + EOF
            block_length = (patch[cursor] << 8) | patch[cursor + 1]
            cursor += 2
            data = block_length * patch[cursor:cursor + 1]
            cursor += 1
        else:
            assert cursor <= -(block_length + len(IPS_EOF))  # Space for data + EOF
            data = patch[cursor:cursor + block_length]
            cursor += block_length
        if len(changed) < block_offset:
            changed = changed + (b'\0' * (block_offset - len(changed)))
        if not force: assert changed[block_offset:block_offset + block_length] != data  # Already applied?
        changed = changed[:block_offset] + data + changed[block_offset + block_length:]
        next_offset = block_offset + block_length
    assert cursor == 0
    return changed

def main(ips_file_name, original_file_name, changed_file_name, force = False):
    if not force: assert os.path.splitext(ips_file_name)[-1].lower() == '.ips'
    patch = open(ips_file_name, 'rb').read()
    original = open(original_file_name, 'rb').read()
    changed = apply_ips(patch, original, force = force)
    open(changed_file_name, 'wb').write(changed)

if __name__ == '__main__':
    force = False
    if sys.argv[1:2] in (['-force'], ['--force']):
        force = True
        try:
            (_, _force, ips_file_name, original_file_name) = sys.argv
            changed_file_name = os.path.join(os.path.split(original_file_name)[0], os.path.splitext(os.path.split(ips_file_name)[1])[0] + os.path.splitext(original_file_name)[1])
        except:
            (_, _force, ips_file_name, original_file_name, changed_file_name) = sys.argv
        assert _force in ('-force', '--force')
    else:
        try:
            (_, ips_file_name, original_file_name) = sys.argv
            changed_file_name = os.path.join(os.path.split(original_file_name)[0], os.path.splitext(os.path.split(ips_file_name)[1])[0] + os.path.splitext(original_file_name)[1])
        except:
            (_, ips_file_name, original_file_name, changed_file_name) = sys.argv
    main(ips_file_name, original_file_name, changed_file_name, force = force)
banner.txt

                             
._ o.__._|_ _  ._ _    |_|_o 
|_)||(_| |_(/_ | | ||_|| |_| 
|                            
 """""                       
"     " "    " "    " "    " 
"     "  "  "   "  "   "  "  
 """""    ""     ""     ""   
"     "   ""     ""     ""   
"     "  "  "   "  "   "  "  
 """""  "    " "    " "    " 
                             
numdebug.asc

10 SCREEN0:WIDTH40:KEYOFF:CLS
20 I$=""
30 INPUT"STR";I$:IFI$=""THENEND
40 ONERRORGOTO200:V#=VAL(I$):ONERRORGOTO0
50 PRINT"VAL="V#
60 ONERRORGOTO100:B$=MKI$(V#):ONERRORGOTO0
70 PRINT"INT="CVI(B$);"&H";HEX$(CVI(B$));" &O";OCT$(CVI(B$));" &B";BIN$(CVI(B$))
80 GOSUB220
90 GOTO110
100 RESUME90
110 ONERRORGOTO150:B$=MKS$(V#):ONERRORGOTO0
120 PRINT"SNG="CVS(B$)
130 GOSUB220
140 GOTO160
150 RESUME140
160 ONERRORGOTO200:B$=MKD$(V#):ONERRORGOTO0
170 PRINT"DBL="CVD(B$)
180 GOSUB220
190 GOTO210
200 RESUME190
210 GOTO20
220 X$=""
230 X$=X$+RIGHT$("0"+HEX$(ASC(MID$(B$,1+LEN(X$)\2,1))),2):IFLEN(X$)<LEN(B$)*2THEN230
240 PRINT" => "X$
250 RETURN
260 V#=CVD(CHR$(1)+"#Eg"+CHR$(&H89)+CHR$(&HAB)+CHR$(&HCD)+CHR$(&HEF)):GOTO50
270 B$=MKD$(-1E-64/-9.9999999999999#):GOSUB220:PRINTCVD(B$)'
numtests.asc

1 KEY OFF:SCREEN 0:WIDTH 40-40*(PEEK(&H2D)<>0):CLS
100 PRINT "00000000",:S$="0!":PRINT S$
101 B$=MKI$(&H0)+MKI$(&H0):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
102 PRINT 0!,VAL(S$):IF(MKS$(0!)<>B$)AND(ASC(B$)MOD128)THENSTOP
103 PRINT "0000000000000000",:S$="0#":PRINT S$
104 B$=MKI$(&H0)+MKI$(&H0)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
105 PRINT 0#,VAL(S$):IF(MKD$(0#)<>B$)AND(ASC(B$)MOD128)THENSTOP
106 PRINT "0000000000000001",:S$="0.0000000000001E-65":PRINT S$
107 B$=MKI$(&H0)+MKI$(&H0)+MKI$(&H0)+MKI$(&H100):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
108 PRINT "Would overflow":REM PRINT 0.0000000000001E-65,VAL(S$):IF(MKD$(0.0000000000001E-65)<>B$)AND(ASC(B$)MOD128)THENSTOP
109 PRINT "00000001",:S$="0.00001E-65":PRINT S$
110 B$=MKI$(&H0)+MKI$(&H100):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
111 PRINT "Would overflow":REM PRINT 0.00001E-65,VAL(S$):IF(MKS$(0.00001E-65)<>B$)AND(ASC(B$)MOD128)THENSTOP
112 PRINT "0000000100000000",:S$="0.0000100E-65":PRINT S$
113 B$=MKI$(&H0)+MKI$(&H100)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
114 PRINT "Would overflow":REM PRINT 0.0000100E-65,VAL(S$):IF(MKD$(0.0000100E-65)<>B$)AND(ASC(B$)MOD128)THENSTOP
115 PRINT "00100000",:S$="1E-65":PRINT S$
116 B$=MKI$(&H1000)+MKI$(&H0):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
117 PRINT 1E-65,VAL(S$):IF(MKS$(1E-65)<>B$)AND(ASC(B$)MOD128)THENSTOP
118 PRINT "0010000000000000",:S$="1.000000E-65":PRINT S$
119 B$=MKI$(&H1000)+MKI$(&H0)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
120 PRINT 1.000000E-65,VAL(S$):IF(MKD$(1.000000E-65)<>B$)AND(ASC(B$)MOD128)THENSTOP
121 PRINT "01100000",:S$="1E-64":PRINT S$
122 B$=MKI$(&H1001)+MKI$(&H0):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
123 PRINT 1E-64,VAL(S$):IF(MKS$(1E-64)<>B$)AND(ASC(B$)MOD128)THENSTOP
124 PRINT "0110000000000000",:S$="1.000000E-64":PRINT S$
125 B$=MKI$(&H1001)+MKI$(&H0)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
126 PRINT 1.000000E-64,VAL(S$):IF(MKD$(1.000000E-64)<>B$)AND(ASC(B$)MOD128)THENSTOP
127 PRINT "01234567",:S$="2.34567E-64":PRINT S$
128 B$=MKI$(&H2301)+MKI$(&H6745):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
129 PRINT 2.34567E-64,VAL(S$):IF(MKS$(2.34567E-64)<>B$)AND(ASC(B$)MOD128)THENSTOP
130 PRINT "0123456700000000",:S$="2.345670E-64":PRINT S$
131 B$=MKI$(&H2301)+MKI$(&H6745)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
132 PRINT 2.345670E-64,VAL(S$):IF(MKD$(2.345670E-64)<>B$)AND(ASC(B$)MOD128)THENSTOP
133 PRINT "0123456789ABCDEF",:S$="2.3456789:;<=>?E-64":PRINT S$
134 B$=MKI$(&H2301)+MKI$(&H6745)+MKI$(&HAB89)+MKI$(&HEFCD):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
135 PRINT "Non-BCD digits":REM PRINT 2.3456789:;<=>?E-64,VAL(S$):IF(MKD$(2.3456789:;<=>?E-64)<>B$)AND(ASC(B$)MOD128)THENSTOP
136 PRINT "11111111",:S$="1.11111E-48":PRINT S$
137 B$=MKI$(&H1111)+MKI$(&H1111):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
138 PRINT 1.11111E-48,VAL(S$):IF(MKS$(1.11111E-48)<>B$)AND(ASC(B$)MOD128)THENSTOP
139 PRINT "1111111100000000",:S$="1.111110E-48":PRINT S$
140 B$=MKI$(&H1111)+MKI$(&H1111)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
141 PRINT 1.111110E-48,VAL(S$):IF(MKD$(1.111110E-48)<>B$)AND(ASC(B$)MOD128)THENSTOP
142 PRINT "1111111111111111",:S$="1.1111111111111E-48":PRINT S$
143 B$=MKI$(&H1111)+MKI$(&H1111)+MKI$(&H1111)+MKI$(&H1111):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
144 PRINT 1.1111111111111E-48,VAL(S$):IF(MKD$(1.1111111111111E-48)<>B$)AND(ASC(B$)MOD128)THENSTOP
145 PRINT "2020202020202020",:S$="2.020202020202E-33":PRINT S$
146 B$=MKI$(&H2020)+MKI$(&H2020)+MKI$(&H2020)+MKI$(&H2020):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
147 PRINT 2.020202020202E-33,VAL(S$):IF(MKD$(2.020202020202E-33)<>B$)AND(ASC(B$)MOD128)THENSTOP
148 PRINT "3E100000",:S$="1E-03":PRINT S$
149 B$=MKI$(&H103E)+MKI$(&H0):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
150 PRINT 1E-03,VAL(S$):IF(MKS$(1E-03)<>B$)AND(ASC(B$)MOD128)THENSTOP
151 PRINT "3E10000000000000",:S$="1.000000E-03":PRINT S$
152 B$=MKI$(&H103E)+MKI$(&H0)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
153 PRINT 1.000000E-03,VAL(S$):IF(MKD$(1.000000E-03)<>B$)AND(ASC(B$)MOD128)THENSTOP
154 PRINT "3E999999",:S$="9.99999E-03":PRINT S$
155 B$=MKI$(&H993E)+MKI$(&H9999):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
156 PRINT 9.99999E-03,VAL(S$):IF(MKS$(9.99999E-03)<>B$)AND(ASC(B$)MOD128)THENSTOP
157 PRINT "3E99999900000000",:S$="9.999990E-03":PRINT S$
158 B$=MKI$(&H993E)+MKI$(&H9999)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
159 PRINT 9.999990E-03,VAL(S$):IF(MKD$(9.999990E-03)<>B$)AND(ASC(B$)MOD128)THENSTOP
160 PRINT "3E99999999999999",:S$="9.9999999999999E-03":PRINT S$
161 B$=MKI$(&H993E)+MKI$(&H9999)+MKI$(&H9999)+MKI$(&H9999):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
162 PRINT 9.9999999999999E-03,VAL(S$):IF(MKD$(9.9999999999999E-03)<>B$)AND(ASC(B$)MOD128)THENSTOP
163 PRINT "3F100000",:S$=".01":PRINT S$
164 B$=MKI$(&H103F)+MKI$(&H0):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
165 PRINT .01,VAL(S$):IF(MKS$(.01)<>B$)AND(ASC(B$)MOD128)THENSTOP
166 PRINT "3F10000000000000",:S$=".01#":PRINT S$
167 B$=MKI$(&H103F)+MKI$(&H0)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
168 PRINT .01#,VAL(S$):IF(MKD$(.01#)<>B$)AND(ASC(B$)MOD128)THENSTOP
169 PRINT "40100000",:S$=".1":PRINT S$
170 B$=MKI$(&H1040)+MKI$(&H0):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
171 PRINT .1,VAL(S$):IF(MKS$(.1)<>B$)AND(ASC(B$)MOD128)THENSTOP
172 PRINT "4010000000000000",:S$=".1#":PRINT S$
173 B$=MKI$(&H1040)+MKI$(&H0)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
174 PRINT .1#,VAL(S$):IF(MKD$(.1#)<>B$)AND(ASC(B$)MOD128)THENSTOP
175 PRINT "40999999",:S$=".999999":PRINT S$
176 B$=MKI$(&H9940)+MKI$(&H9999):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
177 PRINT .999999,VAL(S$):IF(MKS$(.999999)<>B$)AND(ASC(B$)MOD128)THENSTOP
178 PRINT "4099999900000000",:S$=".999999#":PRINT S$
179 B$=MKI$(&H9940)+MKI$(&H9999)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
180 PRINT .999999#,VAL(S$):IF(MKD$(.999999#)<>B$)AND(ASC(B$)MOD128)THENSTOP
181 PRINT "4099999999999999",:S$=".99999999999999#":PRINT S$
182 B$=MKI$(&H9940)+MKI$(&H9999)+MKI$(&H9999)+MKI$(&H9999):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
183 PRINT .99999999999999#,VAL(S$):IF(MKD$(.99999999999999#)<>B$)AND(ASC(B$)MOD128)THENSTOP
184 PRINT "41100000",:S$="1!":PRINT S$
185 B$=MKI$(&H1041)+MKI$(&H0):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
186 PRINT 1!,VAL(S$):IF(MKS$(1!)<>B$)AND(ASC(B$)MOD128)THENSTOP
187 PRINT "4110000000000000",:S$="1#":PRINT S$
188 B$=MKI$(&H1041)+MKI$(&H0)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
189 PRINT 1#,VAL(S$):IF(MKD$(1#)<>B$)AND(ASC(B$)MOD128)THENSTOP
190 PRINT "41900000",:S$="9!":PRINT S$
191 B$=MKI$(&H9041)+MKI$(&H0):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
192 PRINT 9!,VAL(S$):IF(MKS$(9!)<>B$)AND(ASC(B$)MOD128)THENSTOP
193 PRINT "4190000000000000",:S$="9#":PRINT S$
194 B$=MKI$(&H9041)+MKI$(&H0)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
195 PRINT 9#,VAL(S$):IF(MKD$(9#)<>B$)AND(ASC(B$)MOD128)THENSTOP
196 PRINT "41999999",:S$="9.99999":PRINT S$
197 B$=MKI$(&H9941)+MKI$(&H9999):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
198 PRINT 9.99999,VAL(S$):IF(MKS$(9.99999)<>B$)AND(ASC(B$)MOD128)THENSTOP
199 PRINT "4199999900000000",:S$="9.99999#":PRINT S$
200 B$=MKI$(&H9941)+MKI$(&H9999)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
201 PRINT 9.99999#,VAL(S$):IF(MKD$(9.99999#)<>B$)AND(ASC(B$)MOD128)THENSTOP
202 PRINT "4199999999999999",:S$="9.9999999999999#":PRINT S$
203 B$=MKI$(&H9941)+MKI$(&H9999)+MKI$(&H9999)+MKI$(&H9999):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
204 PRINT 9.9999999999999#,VAL(S$):IF(MKD$(9.9999999999999#)<>B$)AND(ASC(B$)MOD128)THENSTOP
205 PRINT "43123123",:S$="123.123":PRINT S$
206 B$=MKI$(&H1243)+MKI$(&H2331):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
207 PRINT 123.123,VAL(S$):IF(MKS$(123.123)<>B$)AND(ASC(B$)MOD128)THENSTOP
208 PRINT "4312312300000000",:S$="123.123#":PRINT S$
209 B$=MKI$(&H1243)+MKI$(&H2331)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
210 PRINT 123.123#,VAL(S$):IF(MKD$(123.123#)<>B$)AND(ASC(B$)MOD128)THENSTOP
211 PRINT "4312312345678901",:S$="123.12345678901#":PRINT S$
212 B$=MKI$(&H1243)+MKI$(&H2331)+MKI$(&H6745)+MKI$(&H189):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
213 PRINT 123.12345678901#,VAL(S$):IF(MKD$(123.12345678901#)<>B$)AND(ASC(B$)MOD128)THENSTOP
214 PRINT "46123456",:S$="123456!":PRINT S$
215 B$=MKI$(&H1246)+MKI$(&H5634):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
216 PRINT 123456!,VAL(S$):IF(MKS$(123456!)<>B$)AND(ASC(B$)MOD128)THENSTOP
217 PRINT "4612345600000000",:S$="123456#":PRINT S$
218 B$=MKI$(&H1246)+MKI$(&H5634)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
219 PRINT 123456#,VAL(S$):IF(MKD$(123456#)<>B$)AND(ASC(B$)MOD128)THENSTOP
220 PRINT "4612345612345678",:S$="123456.12345678#":PRINT S$
221 B$=MKI$(&H1246)+MKI$(&H5634)+MKI$(&H3412)+MKI$(&H7856):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
222 PRINT 123456.12345678#,VAL(S$):IF(MKD$(123456.12345678#)<>B$)AND(ASC(B$)MOD128)THENSTOP
223 PRINT "46999999",:S$="999999!":PRINT S$
224 B$=MKI$(&H9946)+MKI$(&H9999):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
225 PRINT 999999!,VAL(S$):IF(MKS$(999999!)<>B$)AND(ASC(B$)MOD128)THENSTOP
226 PRINT "4699999900000000",:S$="999999#":PRINT S$
227 B$=MKI$(&H9946)+MKI$(&H9999)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
228 PRINT 999999#,VAL(S$):IF(MKD$(999999#)<>B$)AND(ASC(B$)MOD128)THENSTOP
229 PRINT "47100000",:S$="1000000!":PRINT S$
230 B$=MKI$(&H1047)+MKI$(&H0):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
231 PRINT 1000000!,VAL(S$):IF(MKS$(1000000!)<>B$)AND(ASC(B$)MOD128)THENSTOP
232 PRINT "4710000000000000",:S$="1000000#":PRINT S$
233 B$=MKI$(&H1047)+MKI$(&H0)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
234 PRINT 1000000#,VAL(S$):IF(MKD$(1000000#)<>B$)AND(ASC(B$)MOD128)THENSTOP
235 PRINT "4710000010000000",:S$="1000001#":PRINT S$
236 B$=MKI$(&H1047)+MKI$(&H0)+MKI$(&H10)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
237 PRINT 1000001#,VAL(S$):IF(MKD$(1000001#)<>B$)AND(ASC(B$)MOD128)THENSTOP
238 PRINT "4E100000",:S$="10000000000000!":PRINT S$
239 B$=MKI$(&H104E)+MKI$(&H0):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
240 PRINT 10000000000000!,VAL(S$):IF(MKS$(10000000000000!)<>B$)AND(ASC(B$)MOD128)THENSTOP
241 PRINT "4E10000000000000",:S$="10000000000000#":PRINT S$
242 B$=MKI$(&H104E)+MKI$(&H0)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
243 PRINT 10000000000000#,VAL(S$):IF(MKD$(10000000000000#)<>B$)AND(ASC(B$)MOD128)THENSTOP
244 PRINT "4E999999",:S$="99999900000000!":PRINT S$
245 B$=MKI$(&H994E)+MKI$(&H9999):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
246 PRINT 99999900000000!,VAL(S$):IF(MKS$(99999900000000!)<>B$)AND(ASC(B$)MOD128)THENSTOP
247 PRINT "4E99999900000000",:S$="99999900000000#":PRINT S$
248 B$=MKI$(&H994E)+MKI$(&H9999)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
249 PRINT 99999900000000#,VAL(S$):IF(MKD$(99999900000000#)<>B$)AND(ASC(B$)MOD128)THENSTOP
250 PRINT "4E99999999999999",:S$="99999999999999#":PRINT S$
251 B$=MKI$(&H994E)+MKI$(&H9999)+MKI$(&H9999)+MKI$(&H9999):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
252 PRINT 99999999999999#,VAL(S$):IF(MKD$(99999999999999#)<>B$)AND(ASC(B$)MOD128)THENSTOP
253 PRINT "4F100000",:S$="1E+14":PRINT S$
254 B$=MKI$(&H104F)+MKI$(&H0):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
255 PRINT 1E+14,VAL(S$):IF(MKS$(1E+14)<>B$)AND(ASC(B$)MOD128)THENSTOP
256 PRINT "4F10000000000000",:S$="1.000000E+14":PRINT S$
257 B$=MKI$(&H104F)+MKI$(&H0)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
258 PRINT 1.000000E+14,VAL(S$):IF(MKD$(1.000000E+14)<>B$)AND(ASC(B$)MOD128)THENSTOP
259 PRINT "4F10000000000001",:S$="1.0000000000001E+14":PRINT S$
260 B$=MKI$(&H104F)+MKI$(&H0)+MKI$(&H0)+MKI$(&H100):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
261 PRINT 1.0000000000001E+14,VAL(S$):IF(MKD$(1.0000000000001E+14)<>B$)AND(ASC(B$)MOD128)THENSTOP
262 PRINT "60272C2E60272C2E",:S$="2.72<2>60272<2>E+31":PRINT S$
263 B$=MKI$(&H2760)+MKI$(&H2E2C)+MKI$(&H2760)+MKI$(&H2E2C):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
264 PRINT "Non-BCD digits":REM PRINT 2.72<2>60272<2>E+31,VAL(S$):IF(MKD$(2.72<2>60272<2>E+31)<>B$)AND(ASC(B$)MOD128)THENSTOP
265 PRINT "7975636B",:S$="7.5636;E+56":PRINT S$
266 B$=MKI$(&H7579)+MKI$(&H6B63):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
267 PRINT "Non-BCD digits":REM PRINT 7.5636;E+56,VAL(S$):IF(MKS$(7.5636;E+56)<>B$)AND(ASC(B$)MOD128)THENSTOP
268 PRINT "7F7F7F7F",:S$="7.?7?7?E+62":PRINT S$
269 B$=MKI$(&H7F7F)+MKI$(&H7F7F):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
270 PRINT "Non-BCD digits":REM PRINT 7.?7?7?E+62,VAL(S$):IF(MKS$(7.?7?7?E+62)<>B$)AND(ASC(B$)MOD128)THENSTOP
271 PRINT "7F7F7F7F00000000",:S$="7.?7?7?0E+62":PRINT S$
272 B$=MKI$(&H7F7F)+MKI$(&H7F7F)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
273 PRINT "Non-BCD digits":REM PRINT 7.?7?7?0E+62,VAL(S$):IF(MKD$(7.?7?7?0E+62)<>B$)AND(ASC(B$)MOD128)THENSTOP
274 PRINT "7F7F7F7F7F7F7F7F",:S$="7.?7?7?7?7?7?7?E+62":PRINT S$
275 B$=MKI$(&H7F7F)+MKI$(&H7F7F)+MKI$(&H7F7F)+MKI$(&H7F7F):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
276 PRINT "Non-BCD digits":REM PRINT 7.?7?7?7?7?7?7?E+62,VAL(S$):IF(MKD$(7.?7?7?7?7?7?7?E+62)<>B$)AND(ASC(B$)MOD128)THENSTOP
277 PRINT "7F999999",:S$="9.99999E+62":PRINT S$
278 B$=MKI$(&H997F)+MKI$(&H9999):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
279 PRINT 9.99999E+62,VAL(S$):IF(MKS$(9.99999E+62)<>B$)AND(ASC(B$)MOD128)THENSTOP
280 PRINT "7F99999900000000",:S$="9.999990E+62":PRINT S$
281 B$=MKI$(&H997F)+MKI$(&H9999)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
282 PRINT 9.999990E+62,VAL(S$):IF(MKD$(9.999990E+62)<>B$)AND(ASC(B$)MOD128)THENSTOP
283 PRINT "7F99999999999999",:S$="9.9999999999999E+62":PRINT S$
284 B$=MKI$(&H997F)+MKI$(&H9999)+MKI$(&H9999)+MKI$(&H9999):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
285 PRINT 9.9999999999999E+62,VAL(S$):IF(MKD$(9.9999999999999E+62)<>B$)AND(ASC(B$)MOD128)THENSTOP
286 PRINT "7FFFFFFF",:S$="?.?????E+62":PRINT S$
287 B$=MKI$(&HFF7F)+MKI$(&HFFFF):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
288 PRINT "Non-BCD digits":REM PRINT ?.?????E+62,VAL(S$):IF(MKS$(?.?????E+62)<>B$)AND(ASC(B$)MOD128)THENSTOP
289 PRINT "7FFFFFFF00000000",:S$="?.?????0E+62":PRINT S$
290 B$=MKI$(&HFF7F)+MKI$(&HFFFF)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
291 PRINT "Non-BCD digits":REM PRINT ?.?????0E+62,VAL(S$):IF(MKD$(?.?????0E+62)<>B$)AND(ASC(B$)MOD128)THENSTOP
292 PRINT "7FFFFFFFFFFFFFFF",:S$="?.?????????????E+62":PRINT S$
293 B$=MKI$(&HFF7F)+MKI$(&HFFFF)+MKI$(&HFFFF)+MKI$(&HFFFF):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
294 PRINT "Non-BCD digits":REM PRINT ?.?????????????E+62,VAL(S$):IF(MKD$(?.?????????????E+62)<>B$)AND(ASC(B$)MOD128)THENSTOP
295 PRINT "80000000",:S$="-0E-65":PRINT S$
296 B$=MKI$(&H80)+MKI$(&H0):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
297 PRINT -0E-65,VAL(S$):IF(MKS$(-0E-65)<>B$)AND(ASC(B$)MOD128)THENSTOP
298 PRINT "8000000000000000",:S$="-0.0000000E-65":PRINT S$
299 B$=MKI$(&H80)+MKI$(&H0)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
300 PRINT -0.0000000E-65,VAL(S$):IF(MKD$(-0.0000000E-65)<>B$)AND(ASC(B$)MOD128)THENSTOP
301 PRINT "8000000000000001",:S$="-0.0000000000001E-65":PRINT S$
302 B$=MKI$(&H80)+MKI$(&H0)+MKI$(&H0)+MKI$(&H100):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
303 PRINT "Would overflow":REM PRINT -0.0000000000001E-65,VAL(S$):IF(MKD$(-0.0000000000001E-65)<>B$)AND(ASC(B$)MOD128)THENSTOP
304 PRINT "80000001",:S$="-0.00001E-65":PRINT S$
305 B$=MKI$(&H80)+MKI$(&H100):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
306 PRINT "Would overflow":REM PRINT -0.00001E-65,VAL(S$):IF(MKS$(-0.00001E-65)<>B$)AND(ASC(B$)MOD128)THENSTOP
307 PRINT "8000000100000000",:S$="-0.0000100E-65":PRINT S$
308 B$=MKI$(&H80)+MKI$(&H100)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
309 PRINT "Would overflow":REM PRINT -0.0000100E-65,VAL(S$):IF(MKD$(-0.0000100E-65)<>B$)AND(ASC(B$)MOD128)THENSTOP
310 PRINT "80100000",:S$="-1E-65":PRINT S$
311 B$=MKI$(&H1080)+MKI$(&H0):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
312 PRINT -1E-65,VAL(S$):IF(MKS$(-1E-65)<>B$)AND(ASC(B$)MOD128)THENSTOP
313 PRINT "8010000000000000",:S$="-1.000000E-65":PRINT S$
314 B$=MKI$(&H1080)+MKI$(&H0)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
315 PRINT -1.000000E-65,VAL(S$):IF(MKD$(-1.000000E-65)<>B$)AND(ASC(B$)MOD128)THENSTOP
316 PRINT "81100000",:S$="-1E-64":PRINT S$
317 B$=MKI$(&H1081)+MKI$(&H0):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
318 PRINT -1E-64,VAL(S$):IF(MKS$(-1E-64)<>B$)AND(ASC(B$)MOD128)THENSTOP
319 PRINT "8110000000000000",:S$="-1.000000E-64":PRINT S$
320 B$=MKI$(&H1081)+MKI$(&H0)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
321 PRINT -1.000000E-64,VAL(S$):IF(MKD$(-1.000000E-64)<>B$)AND(ASC(B$)MOD128)THENSTOP
322 PRINT "99999999",:S$="-9.99999E-40":PRINT S$
323 B$=MKI$(&H9999)+MKI$(&H9999):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
324 PRINT -9.99999E-40,VAL(S$):IF(MKS$(-9.99999E-40)<>B$)AND(ASC(B$)MOD128)THENSTOP
325 PRINT "9999999900000000",:S$="-9.999990E-40":PRINT S$
326 B$=MKI$(&H9999)+MKI$(&H9999)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
327 PRINT -9.999990E-40,VAL(S$):IF(MKD$(-9.999990E-40)<>B$)AND(ASC(B$)MOD128)THENSTOP
328 PRINT "9999999999999999",:S$="-9.9999999999999E-40":PRINT S$
329 B$=MKI$(&H9999)+MKI$(&H9999)+MKI$(&H9999)+MKI$(&H9999):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
330 PRINT -9.9999999999999E-40,VAL(S$):IF(MKD$(-9.9999999999999E-40)<>B$)AND(ASC(B$)MOD128)THENSTOP
331 PRINT "BE100000",:S$="-1E-03":PRINT S$
332 B$=MKI$(&H10BE)+MKI$(&H0):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
333 PRINT -1E-03,VAL(S$):IF(MKS$(-1E-03)<>B$)AND(ASC(B$)MOD128)THENSTOP
334 PRINT "BE10000000000000",:S$="-1.000000E-03":PRINT S$
335 B$=MKI$(&H10BE)+MKI$(&H0)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
336 PRINT -1.000000E-03,VAL(S$):IF(MKD$(-1.000000E-03)<>B$)AND(ASC(B$)MOD128)THENSTOP
337 PRINT "BE999999",:S$="-9.99999E-03":PRINT S$
338 B$=MKI$(&H99BE)+MKI$(&H9999):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
339 PRINT -9.99999E-03,VAL(S$):IF(MKS$(-9.99999E-03)<>B$)AND(ASC(B$)MOD128)THENSTOP
340 PRINT "BE99999900000000",:S$="-9.999990E-03":PRINT S$
341 B$=MKI$(&H99BE)+MKI$(&H9999)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
342 PRINT -9.999990E-03,VAL(S$):IF(MKD$(-9.999990E-03)<>B$)AND(ASC(B$)MOD128)THENSTOP
343 PRINT "BE99999999999999",:S$="-9.9999999999999E-03":PRINT S$
344 B$=MKI$(&H99BE)+MKI$(&H9999)+MKI$(&H9999)+MKI$(&H9999):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
345 PRINT -9.9999999999999E-03,VAL(S$):IF(MKD$(-9.9999999999999E-03)<>B$)AND(ASC(B$)MOD128)THENSTOP
346 PRINT "BF100000",:S$="-.01":PRINT S$
347 B$=MKI$(&H10BF)+MKI$(&H0):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
348 PRINT -.01,VAL(S$):IF(MKS$(-.01)<>B$)AND(ASC(B$)MOD128)THENSTOP
349 PRINT "BF10000000000000",:S$="-.01#":PRINT S$
350 B$=MKI$(&H10BF)+MKI$(&H0)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
351 PRINT -.01#,VAL(S$):IF(MKD$(-.01#)<>B$)AND(ASC(B$)MOD128)THENSTOP
352 PRINT "C0100000",:S$="-.1":PRINT S$
353 B$=MKI$(&H10C0)+MKI$(&H0):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
354 PRINT -.1,VAL(S$):IF(MKS$(-.1)<>B$)AND(ASC(B$)MOD128)THENSTOP
355 PRINT "C010000000000000",:S$="-.1#":PRINT S$
356 B$=MKI$(&H10C0)+MKI$(&H0)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
357 PRINT -.1#,VAL(S$):IF(MKD$(-.1#)<>B$)AND(ASC(B$)MOD128)THENSTOP
358 PRINT "C0999999",:S$="-.999999":PRINT S$
359 B$=MKI$(&H99C0)+MKI$(&H9999):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
360 PRINT -.999999,VAL(S$):IF(MKS$(-.999999)<>B$)AND(ASC(B$)MOD128)THENSTOP
361 PRINT "C099999900000000",:S$="-.999999#":PRINT S$
362 B$=MKI$(&H99C0)+MKI$(&H9999)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
363 PRINT -.999999#,VAL(S$):IF(MKD$(-.999999#)<>B$)AND(ASC(B$)MOD128)THENSTOP
364 PRINT "C099999999999999",:S$="-.99999999999999#":PRINT S$
365 B$=MKI$(&H99C0)+MKI$(&H9999)+MKI$(&H9999)+MKI$(&H9999):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
366 PRINT -.99999999999999#,VAL(S$):IF(MKD$(-.99999999999999#)<>B$)AND(ASC(B$)MOD128)THENSTOP
367 PRINT "C1100000",:S$="-1!":PRINT S$
368 B$=MKI$(&H10C1)+MKI$(&H0):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
369 PRINT -1!,VAL(S$):IF(MKS$(-1!)<>B$)AND(ASC(B$)MOD128)THENSTOP
370 PRINT "C110000000000000",:S$="-1#":PRINT S$
371 B$=MKI$(&H10C1)+MKI$(&H0)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
372 PRINT -1#,VAL(S$):IF(MKD$(-1#)<>B$)AND(ASC(B$)MOD128)THENSTOP
373 PRINT "C1900000",:S$="-9!":PRINT S$
374 B$=MKI$(&H90C1)+MKI$(&H0):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
375 PRINT -9!,VAL(S$):IF(MKS$(-9!)<>B$)AND(ASC(B$)MOD128)THENSTOP
376 PRINT "C190000000000000",:S$="-9#":PRINT S$
377 B$=MKI$(&H90C1)+MKI$(&H0)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
378 PRINT -9#,VAL(S$):IF(MKD$(-9#)<>B$)AND(ASC(B$)MOD128)THENSTOP
379 PRINT "C1999999",:S$="-9.99999":PRINT S$
380 B$=MKI$(&H99C1)+MKI$(&H9999):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
381 PRINT -9.99999,VAL(S$):IF(MKS$(-9.99999)<>B$)AND(ASC(B$)MOD128)THENSTOP
382 PRINT "C199999900000000",:S$="-9.99999#":PRINT S$
383 B$=MKI$(&H99C1)+MKI$(&H9999)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
384 PRINT -9.99999#,VAL(S$):IF(MKD$(-9.99999#)<>B$)AND(ASC(B$)MOD128)THENSTOP
385 PRINT "C199999999999999",:S$="-9.9999999999999#":PRINT S$
386 B$=MKI$(&H99C1)+MKI$(&H9999)+MKI$(&H9999)+MKI$(&H9999):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
387 PRINT -9.9999999999999#,VAL(S$):IF(MKD$(-9.9999999999999#)<>B$)AND(ASC(B$)MOD128)THENSTOP
388 PRINT "C3123123",:S$="-123.123":PRINT S$
389 B$=MKI$(&H12C3)+MKI$(&H2331):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
390 PRINT -123.123,VAL(S$):IF(MKS$(-123.123)<>B$)AND(ASC(B$)MOD128)THENSTOP
391 PRINT "C312312300000000",:S$="-123.123#":PRINT S$
392 B$=MKI$(&H12C3)+MKI$(&H2331)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
393 PRINT -123.123#,VAL(S$):IF(MKD$(-123.123#)<>B$)AND(ASC(B$)MOD128)THENSTOP
394 PRINT "C312312345678901",:S$="-123.12345678901#":PRINT S$
395 B$=MKI$(&H12C3)+MKI$(&H2331)+MKI$(&H6745)+MKI$(&H189):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
396 PRINT -123.12345678901#,VAL(S$):IF(MKD$(-123.12345678901#)<>B$)AND(ASC(B$)MOD128)THENSTOP
397 PRINT "C6123456",:S$="-123456!":PRINT S$
398 B$=MKI$(&H12C6)+MKI$(&H5634):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
399 PRINT -123456!,VAL(S$):IF(MKS$(-123456!)<>B$)AND(ASC(B$)MOD128)THENSTOP
400 PRINT "C612345600000000",:S$="-123456#":PRINT S$
401 B$=MKI$(&H12C6)+MKI$(&H5634)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
402 PRINT -123456#,VAL(S$):IF(MKD$(-123456#)<>B$)AND(ASC(B$)MOD128)THENSTOP
403 PRINT "C612345612345678",:S$="-123456.12345678#":PRINT S$
404 B$=MKI$(&H12C6)+MKI$(&H5634)+MKI$(&H3412)+MKI$(&H7856):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
405 PRINT -123456.12345678#,VAL(S$):IF(MKD$(-123456.12345678#)<>B$)AND(ASC(B$)MOD128)THENSTOP
406 PRINT "C6999999",:S$="-999999!":PRINT S$
407 B$=MKI$(&H99C6)+MKI$(&H9999):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
408 PRINT -999999!,VAL(S$):IF(MKS$(-999999!)<>B$)AND(ASC(B$)MOD128)THENSTOP
409 PRINT "C699999900000000",:S$="-999999#":PRINT S$
410 B$=MKI$(&H99C6)+MKI$(&H9999)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
411 PRINT -999999#,VAL(S$):IF(MKD$(-999999#)<>B$)AND(ASC(B$)MOD128)THENSTOP
412 PRINT "C7100000",:S$="-1000000!":PRINT S$
413 B$=MKI$(&H10C7)+MKI$(&H0):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
414 PRINT -1000000!,VAL(S$):IF(MKS$(-1000000!)<>B$)AND(ASC(B$)MOD128)THENSTOP
415 PRINT "C710000000000000",:S$="-1000000#":PRINT S$
416 B$=MKI$(&H10C7)+MKI$(&H0)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
417 PRINT -1000000#,VAL(S$):IF(MKD$(-1000000#)<>B$)AND(ASC(B$)MOD128)THENSTOP
418 PRINT "C710000010000000",:S$="-1000001#":PRINT S$
419 B$=MKI$(&H10C7)+MKI$(&H0)+MKI$(&H10)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
420 PRINT -1000001#,VAL(S$):IF(MKD$(-1000001#)<>B$)AND(ASC(B$)MOD128)THENSTOP
421 PRINT "CCCCCCCCCCCCCCCC",:S$="-<<<<<<<<<<<<.<<#":PRINT S$
422 B$=MKI$(&HCCCC)+MKI$(&HCCCC)+MKI$(&HCCCC)+MKI$(&HCCCC):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
423 PRINT "Non-BCD digits":REM PRINT -<<<<<<<<<<<<.<<#,VAL(S$):IF(MKD$(-<<<<<<<<<<<<.<<#)<>B$)AND(ASC(B$)MOD128)THENSTOP
424 PRINT "CE100000",:S$="-10000000000000!":PRINT S$
425 B$=MKI$(&H10CE)+MKI$(&H0):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
426 PRINT -10000000000000!,VAL(S$):IF(MKS$(-10000000000000!)<>B$)AND(ASC(B$)MOD128)THENSTOP
427 PRINT "CE10000000000000",:S$="-10000000000000#":PRINT S$
428 B$=MKI$(&H10CE)+MKI$(&H0)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
429 PRINT -10000000000000#,VAL(S$):IF(MKD$(-10000000000000#)<>B$)AND(ASC(B$)MOD128)THENSTOP
430 PRINT "CE999999",:S$="-99999900000000!":PRINT S$
431 B$=MKI$(&H99CE)+MKI$(&H9999):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
432 PRINT -99999900000000!,VAL(S$):IF(MKS$(-99999900000000!)<>B$)AND(ASC(B$)MOD128)THENSTOP
433 PRINT "CE99999900000000",:S$="-99999900000000#":PRINT S$
434 B$=MKI$(&H99CE)+MKI$(&H9999)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
435 PRINT -99999900000000#,VAL(S$):IF(MKD$(-99999900000000#)<>B$)AND(ASC(B$)MOD128)THENSTOP
436 PRINT "CE99999999999999",:S$="-99999999999999#":PRINT S$
437 B$=MKI$(&H99CE)+MKI$(&H9999)+MKI$(&H9999)+MKI$(&H9999):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
438 PRINT -99999999999999#,VAL(S$):IF(MKD$(-99999999999999#)<>B$)AND(ASC(B$)MOD128)THENSTOP
439 PRINT "CF100000",:S$="-1E+14":PRINT S$
440 B$=MKI$(&H10CF)+MKI$(&H0):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
441 PRINT -1E+14,VAL(S$):IF(MKS$(-1E+14)<>B$)AND(ASC(B$)MOD128)THENSTOP
442 PRINT "CF10000000000000",:S$="-1.000000E+14":PRINT S$
443 B$=MKI$(&H10CF)+MKI$(&H0)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
444 PRINT -1.000000E+14,VAL(S$):IF(MKD$(-1.000000E+14)<>B$)AND(ASC(B$)MOD128)THENSTOP
445 PRINT "CF10000000000001",:S$="-1.0000000000001E+14":PRINT S$
446 B$=MKI$(&H10CF)+MKI$(&H0)+MKI$(&H0)+MKI$(&H100):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
447 PRINT -1.0000000000001E+14,VAL(S$):IF(MKD$(-1.0000000000001E+14)<>B$)AND(ASC(B$)MOD128)THENSTOP
448 PRINT "FF999999",:S$="-9.99999E+62":PRINT S$
449 B$=MKI$(&H99FF)+MKI$(&H9999):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
450 PRINT -9.99999E+62,VAL(S$):IF(MKS$(-9.99999E+62)<>B$)AND(ASC(B$)MOD128)THENSTOP
451 PRINT "FF99999900000000",:S$="-9.999990E+62":PRINT S$
452 B$=MKI$(&H99FF)+MKI$(&H9999)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
453 PRINT -9.999990E+62,VAL(S$):IF(MKD$(-9.999990E+62)<>B$)AND(ASC(B$)MOD128)THENSTOP
454 PRINT "FF99999999999999",:S$="-9.9999999999999E+62":PRINT S$
455 B$=MKI$(&H99FF)+MKI$(&H9999)+MKI$(&H9999)+MKI$(&H9999):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
456 PRINT -9.9999999999999E+62,VAL(S$):IF(MKD$(-9.9999999999999E+62)<>B$)AND(ASC(B$)MOD128)THENSTOP
457 PRINT "FFFFFFFF",:S$="-?.?????E+62":PRINT S$
458 B$=MKI$(&HFFFF)+MKI$(&HFFFF):PRINT CVS(B$),:IF MKS$(CVS(B$))<>B$ THEN PRINT"binary<>":STOP
459 PRINT "Non-BCD digits":REM PRINT -?.?????E+62,VAL(S$):IF(MKS$(-?.?????E+62)<>B$)AND(ASC(B$)MOD128)THENSTOP
460 PRINT "FFFFFFFF00000000",:S$="-?.?????0E+62":PRINT S$
461 B$=MKI$(&HFFFF)+MKI$(&HFFFF)+MKI$(&H0)+MKI$(&H0):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
462 PRINT "Non-BCD digits":REM PRINT -?.?????0E+62,VAL(S$):IF(MKD$(-?.?????0E+62)<>B$)AND(ASC(B$)MOD128)THENSTOP
463 PRINT "FFFFFFFFFFFFFFFF",:S$="-?.?????????????E+62":PRINT S$
464 B$=MKI$(&HFFFF)+MKI$(&HFFFF)+MKI$(&HFFFF)+MKI$(&HFFFF):PRINT CVD(B$),:IF MKD$(CVD(B$))<>B$ THEN PRINT"binary<>":STOP
465 PRINT "Non-BCD digits":REM PRINT -?.?????????????E+62,VAL(S$):IF(MKD$(-?.?????????????E+62)<>B$)AND(ASC(B$)MOD128)THENSTOP
65522 PRINT"ran all numtests":SAVE"numtests.bas"
boot.rom (hexdump)

00000000  41 42 00 5f 00 00 00 00  00 00 00 00 00 00 00 00  |AB._............|
00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
00001f00  f3 f5 e5 d5 c5 cd 38 01  0f 0f e6 03 4f 06 00 21  |......8.....O..!|
00001f10  c1 fc 09 7e e6 80 b1 cb  7f 28 09 4f 23 23 23 23  |...~.....(.O####|
00001f20  7e e6 c0 b1 26 80 cd 24  00 af 00 00 ee 01 32 00  |~...&..$......2.|
00001f30  80 32 00 90 32 00 a0 32  00 b0 c1 d1 e1 f1 fb c9  |.2..2..2........|
00001f40  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
00002000
list of slot contents i built mine with:

fb70350a46ea7548913bf0c07cbddccffebd0650 slot-00-mars-lander-7k.asc
ef72dc1cf8b80e502240919cd610d201443fd2ee slot-01-ice-man-4k.asc
b5d130a50f6939028702c1645426a29ec8ead6e5 slot-02-mr-chin-8k.rom
a53d1ea775a6c90a84f1f36349540b16cf8307e4 slot-03-jump-coaster-8k.rom
cad653766b597a4aa130a9a1956ece77ba4d52bc slot-04-pachinko-ufo-16k.rom
0b9a870d1e6cc712a3efce2349fb1c1cf6902d22 slot-06-chack-n-pop-16k.rom
99f9e9753edbaee820e36a1a58f1cd7ae2b26265 slot-08-choro-q-16k.rom
5c7a13b64b48065231f05c35b4c8b209534f3a8b slot-0a-f16-fighting-falcon-16k.rom
2dacf7a08857cbdc706d24b4a46665113d16ff99 slot-0c-gojira-16k.rom
167b226b54cc5b681a69d2c1509116ffaba868e4 slot-0e-ice-world-16k.rom
5d22776defba52108624f5bfbf28d4a453ea5cf4 slot-10-spacescape-7k.asc
3302288f2e9fe9cf3d8fc589a460bfcf110de4c5 slot-11-space-mines-4k.asc
c5cdd1109b1e24906c5f0530f09e9ec95fbd7bb0 slot-12-flapbir1-8k.rom
8e2a2837c48bc8e2d2478043c728a4630982ba87 slot-13-clapton-2-8k.rom
8aa6d0aadf00de9112696da5b7dc6e3b62f2d9be slot-14-theseus-16k.rom
39ef139d8d66fb18b04dff8b9a5386011f497479 slot-16-jump-16k.rom
5460aa3be896ad949bea75444bc6e7e072a859b8 slot-18-midnight-building-16k.rom
917270dd44c63dc883289b4e0902fe6c812f5ea3 slot-1a-gundam-16k.rom
f3952b790ae2a8a1434b52bf816c56c9e680f73e slot-1c-hole-in-one-16k.rom
1fbd7af23177ab1de799764d8a26bc2bbf85b042 slot-1e-pinky-chase-16k.rom
e608f7a1363deef42771c24f83acb4af3601b921 slot-20-pinball-7k.asc
5bb0e79a79703f04eddc3b34e6e8b66a3b4bf671 slot-21-ufo-4k.asc
27e56fbec7fa39ce19d045b0dbc4217d290f92e2 slot-22-picture-puzzle-8k.rom
0e63032a21ea4e42b67df98a24c2c30c6d88c319 slot-23-pyramid-warp-8k.rom
78079266711e60420480e4d95a39f0d7d974ad32 slot-24-pitfall-2-16k.rom
1edabc3226648b54ae98d524b31f37ca47c8c88b slot-26-rock-n-bolt-16k.rom
a4be5763cdf2dcd647b87e3aecbab28ecc69776e slot-28-tantan-tanuki-16k.rom
04bd78730b100dd879e2fbd3fe646d2bc9bbc46b slot-2a-soukoban-16k.rom
15cc2f7412373253e908689a778738d52656ad74 slot-2c-xyzolog-16k.rom
221c76d6ac483fb1f11c87d37b9617f1e1d7bc6d slot-2e-sweet-acorn-16k.rom
40ac9691fa569c9ed3381bcefa9aa3375af299b1 slot-30-freeball-2-3-8-9-7k.asc
d1597a4b29803b566b3cdb274ff30b406b1c18fc slot-31-galactor-4k.asc
5db0acc008672f298d01686da4d56428b690b77f slot-32-snail-maze-8k.rom
190bcab0325ded99f42f32976bf965f0164ad2a4 slot-33-peetan-8k.rom
f6711e1e2bac04d45b8988f1d03529ad777abf4e slot-34-tetsuman-16k.rom
4971bdd3db63d394fbc2186182c901ca4b32535b slot-36-space-invaders-16k.rom
5b17cb69697cf55dff1f0b8777e19d5abc1771fc slot-38-daishogai-keiba-16k.rom
de5b45cfb2fa20ca55f225085c2e6c3ccc314057 slot-3a-pitfall-16k.ips
b88e9c548873dcfd190e0e38f7b279344eea41ec slot-3a-pitfall-16k.rom
8117ec66c0645a54422841a632cfd6602f35c4f9 slot-3c-pastfinder-16k.rom
c294a9fd1ada49bb4707324ec91b28b99c04b749 slot-3e-roller-ball-16k.ips
44baa180f6c9e0f140ac1f0afae75c412cb06b9e slot-3e-roller-ball-16k.rom
By bsittler

Champion (503)

bsittler's picture
10-03-2025, 22:48

Here's the thread describing the cartridge for which I developed these tools https://www.msx.org/forum/msx-talk/hardware/oyanami-a-megaro...